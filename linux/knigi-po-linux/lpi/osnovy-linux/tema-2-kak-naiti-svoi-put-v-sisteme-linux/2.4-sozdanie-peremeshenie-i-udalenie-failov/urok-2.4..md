# Урок 2.4.

### Введение <a href="#sec.2.4_01-in" id="sec.2.4_01-in"></a>

В этом уроке рассказывается об управлении файлами и каталогами в Linux с помощью инструментов командной строки.

Файл - это набор данных с именем и набором атрибутов. Если бы, например, вы перенесли несколько фотографий со своего телефона на компьютер и дали им описательные названия, то теперь у вас на компьютере была бы куча файлов изображений. У этих файлов есть такие атрибуты, как время последнего обращения к файлу или его изменения.

Каталог - это особый вид файла, используемый для упорядочивания файлов. Хороший способ представить каталоги как папки, используемые для упорядочивания документов в картотеке. В отличие от бумажных папок с файлами, вы можете легко помещать каталоги внутри других каталогов.

Командная строка - наиболее эффективный способ управления файлами в системе Linux. Средства командной оболочки и командной строки обладают функциями, которые делают использование командной строки более быстрым и простым, чем графический файловый менеджер.

В этом разделе вы будете использовать команды `ls`, `mv`, `cp`, `pwd`, `find`, `touch`, `rm`, `rmdir`, `echo`, `cat и` `mkdir` для управления файлами и каталогами и их упорядочивания.

## &#x20;Чувствительность к регистру

В отличие от Microsoft Windows, в системах Linux имена файлов и каталогов чувствительны к регистру. Это означает, что имена `/etc/` и `/ETC/` относятся к разным каталогам. Попробуйте выполнить следующие команды:

```
$ cd /
$ ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr
$ cd ETC
bash: cd: ETC: No such file or directory
$ pwd
/
$ cd etc
$ pwd
/etc
```

`pwd` отображает каталог, в котором вы находитесь в данный момент. Как вы можете видеть, переход в каталог `/ETC` не сработало, поскольку такого каталога нет. Переход в каталог `/etc` который существует, прошло успешно.

## &#x20;Создание каталогов

Команда `mkdir` используется для создания каталогов.

Давайте создадим новый каталог в нашем домашнем каталоге:

```
$ cd ~
$ pwd
/home/user
$ ls
Desktop  Documents  Downloads
$ mkdir linux_essentials-2.4
$ ls
Desktop  Documents  Downloads  linux_essentials-2.4
$ cd linux_essentials-2.4
$ pwd
/home/emma/linux_essentials-2.4
```

На протяжении этого урока все команды будут выполняться в этом каталоге или в одном из его подкаталогов.

Чтобы легко вернуться в каталог уроков из любой другой позиции в вашей файловой системе, вы можете использовать команду:

`$ cd ~/linux_essentials-2.4`

Когда вы окажетесь в каталоге с уроками, создайте ещё несколько каталогов, которые мы будем использовать для упражнений. Вы можете добавить все названия каталогов, разделённые пробелами  с командой `mkdir`:

```
$ mkdir creating moving copying/files copying/directories deleting/directories deleting/files globs
mkdir: cannot create directory ‘copying/files’: No such file or directory
mkdir: cannot create directory ‘copying/directories’: No such file or directory
mkdir: cannot create directory ‘deleting/directories’: No such file or directory
mkdir: cannot create directory ‘deleting/files’: No such file or directory
$ ls
creating  globs  moving
```

Обратите внимание на сообщение об ошибке и на то, что были созданы только `moving`, `globs` и `creating`. Каталоги `copying` и `deleting` еще не существуют. `mkdir` по умолчанию не создает каталог внутри каталога, который не существует. Параметр `-p` или `--parents` указывает `mkdir` создать родительские каталоги, если они не существуют. Попробуйте ту же `mkdir` команду с `-p` параметром:

```
$ mkdir -p creating moving copying/files copying/directories deleting/directories deleting/files globs
```

Теперь вы не получаете сообщений об ошибках. Давайте посмотрим, какие каталоги существуют сейчас:

```
$ find
.
./creating
./moving
./globs
./copying
./copying/files
./copying/directories
./deleting
./deleting/directories
./deleting/files
```

Программа `find` обычно используется для поиска файлов и каталогов, но без каких-либо параметров она покажет вам список всех файлов, каталогов и подкаталогов в текущем каталоге.

{% hint style="info" %}
При перечислении содержимого каталога с помощью `ls` особенно удобны параметры `-t` и `-r`. Они сортируют вывод по времени (`-t`) и меняют порядок сортировки на противоположный (`-r`). В этом случае самые новые файлы будут в нижней части вывода.
{% endhint %}

## &#x20;Создание файлов

Обычно файлы создаются программами, которые работают с данными, хранящимися в файлах. Пустой файл можно создать с помощью команды `touch`. Если вы запустите `touch` для существующего файла, содержимое файла изменено не будет, но будет обновлена временная метка изменения файла.

Выполните следующую команду, чтобы создать несколько файлов для урока по глобированию:

```
$ touch globs/question1 globs/question2012 globs/question23 globs/question13 globs/question14
$ touch globs/star10 globs/star1100 globs/star2002 globs/star2013
```

Теперь давайте убедимся, что все файлы существуют в `globs` каталоге:

```
$ cd globs
$ ls
question1   question14    question23  star1100  star2013
question13  question2012  star10      star2002
```

Заметили, как `touch` создал файлы? Вы можете просмотреть содержимое текстового файла с помощью `cat` команды. Попробуйте применить это к одному из только что созданных файлов.:

```
$ cat question14
```

Поскольку `touch` создает пустые файлы, вы не должны получать выходных данных. Вы можете использовать `echo` с `>` для создания простых текстовых файлов. Попробуйте:

```
$ echo hello > question15
$ cat question15
hello
```

`echo` отображает текст в командной строке. Символ `>` указывает командной оболочке записать выходные данные команды в указанный файл вместо вашего терминала. Это приводит к тому, что выходные данные `echo`, `hello` в данном случае, записываются в файл `question15`. Это не относится конкретно к `echo`, его можно использовать с любой командой.

{% hint style="info" %}
Будьте осторожны при использовании `>`! Если указанный файл уже существует, он будет перезаписан!
{% endhint %}

## &#x20;Переименование файлов

Файлы перемещаются и переименовываются с помощью команды `mv`.

Установите для своего рабочего каталога значение `moving` .

```
cd ~/linux_essentials-2.4/moving
```

Создайте несколько файлов для практики. К этому моменту вы уже должны быть знакомы с этими командами:

```
$ touch file1 file22
$ echo file3 > file3
$ echo file4 > file4
$ ls
file1 file22 file3 file4
```

Предположим, что `file22` — это опечатка, и должно быть `file2`. Исправьте это с помощью команды `mv`. При переименовании файла первый аргумент — это текущее имя, второй — новое имя:

```
$ mv file22 file2
$ ls
file1 file2 file3 file4
```

Будьте осторожны с командой `mv`: если вы переименуете файл в имя существующего файла, он будет перезаписан. Давайте проверим это с помощью `file3` и `file4`:

```
$ cat file3
file3
$ cat file4
file4
$ mv file4 file3
$ cat file3
file4
$ ls
file1  file2  file3
```

Обратите внимание, каким стало содержимое `file3` теперь он `file4`. Используйте `-i` опцию, чтобы сделать `mv` запрос, собираетесь ли вы перезаписать существующий файл. Попробуйте:\\

```
$ touch file4 file5
$ mv -i file4 file3
mv: overwrite ‘file3’? y
```

## &#x20;Перемещение файлов

Файлы перемещаются из одного каталога в другой с помощью команды `mv`.

Создайте несколько каталогов для перемещения файлов в них:

```
$ cd ~/linux_essentials-2.4/moving
$ mkdir dir1 dir2
$ ls
dir1  dir2  file1  file2  file3  file
```

Переместите `file1` в `dir1`:

```
$ mv file1 dir1
$ ls
dir1  dir2  file2  file3  file5
$ ls dir1
file1
```

Обратите внимание, что последним аргументом `mv` является целевой каталог. Если последним аргументом `mv` является каталог, файлы перемещаются в него. В одной команде `mv` можно указать несколько файлов:

```
$ mv file2 file3 dir2
$ ls
dir1  dir2  file5
$ ls dir2
file2  file3
```

`mv` также можно использовать для перемещения и переименования каталогов. Переименовать `dir1` в `dir3`:

```
$ ls
dir1  dir2  file5
$ ls dir1
file1
$ mv dir1 dir3
$ ls
dir2  dir3  file5
$ ls dir3
file1
```

## &#x20;Удаление файлов и каталогов

Команда `rm` может удалять файлы и каталоги, в то время как команда `rmdir` может удалять только каталоги. Давайте очистим `moving` каталог, удалив `file5`:

```
$ cd ~/linux_essentials-2.4/moving
$ ls
dir2  dir3  file5
$ rmdir file5
rmdir: failed to remove ‘file5’: Not a directory
$ rm file5
$ ls
dir2  dir3
```

По умолчанию `rmdir` можно удалять только пустые каталоги, поэтому нам пришлось использовать `rm` для удаления обычного файла. Попробуйте удалить `deleting` каталог:

```
$ cd ~/linux_essentials-2.4/
$ ls
copying  creating  deleting  globs  moving
$ rmdir deleting
rmdir: failed to remove ‘deleting’: Directory not empty
$ ls -l deleting
total 0
drwxrwxr-x. 2 emma emma 6 Mar 26 14:58 directories
drwxrwxr-x. 2 emma emma 6 Mar 26 14:58 files
```

По умолчанию `rmdir` не позволяет удалить непустой каталог. Используйте `rmdir` для удаления одного из пустых подкаталогов каталога `deleting`:

```
$ ls -a deleting/files
.  ..
$ rmdir deleting/files
$ ls -l deleting
directories
```

Удаление большого количества файлов или глубоких структур каталогов со множеством подкаталогов может показаться утомительным, но на самом деле это просто. По умолчанию `rm` работает только с обычными файлами. Опция `-r` используется для переопределения этого поведения. Будьте осторожны, `rm -r` это отличный ножной пистолет! При использовании `-r` опции `rm` будут удалены не только любые каталоги, но и все, что находится внутри этого каталога, включая подкаталоги и их содержимое. Посмотрите сами, как это работает `rm -r`

```
$ ls
copying  creating  deleting  globs  moving
$ rm deleting
rm: cannot remove ‘deleting’: Is a directory
$ ls -l deleting
total 0
drwxrwxr-x. 2 emma emma 6 Mar 26 14:58 directories
$ rm -r deleting
$ ls
copying  creating  globs  moving
```

Обратите внимание, что `deleting` исчезло, хотя оно не было пустым? Как и в случае с `mv`, `rm` имеет `-i` опцию, которая запрашивает ваше разрешение перед выполнением каких-либо действий. Используйте `rm -ri` для удаления каталогов из `moving` раздела, которые больше не нужны:

```
$ find
.
./creating
./moving
./moving/dir2
./moving/dir2/file2
./moving/dir2/file3
./moving/dir3
./moving/dir3/file1
./globs
./globs/question1
./globs/question2012
./globs/question23
./globs/question13
./globs/question14
./globs/star10
./globs/star1100
./globs/star2002
./globs/star2013
./globs/question15
./copying
./copying/files
./copying/directories
$ rm -ri moving
rm: descend into directory ‘moving’? y
rm: descend into directory ‘moving/dir2’? y
rm: remove regular empty file ‘moving/dir2/file2’? y
rm: remove regular empty file ‘moving/dir2/file3’? y
rm: remove directory ‘moving/dir2’? y
rm: descend into directory ‘moving/dir3’? y
rm: remove regular empty file ‘moving/dir3/file1’? y
rm: remove directory ‘moving/dir3’? y
rm: remove directory ‘moving’? y
```

## &#x20;Копирование файлов и каталогов

Команда `cp` используется для копирования файлов и директорий. Скопируйте несколько файлов в `copying` директорию:

```
$ cd ~/linux_essentials-2.4/copying
$ ls
directories  files
$ cp /etc/nsswitch.conf files/nsswitch.conf
$ cp /etc/issue /etc/hostname files
```

Если последним аргументом является каталог, `cp` создаст копию предыдущих аргументов внутри каталога. Как и `mv`, можно указать сразу несколько файлов, если целью является каталог.

Если оба операнда `cp` являются файлами и оба файла существуют, `cp` перезаписывает второй файл копией первого файла. Давайте попрактикуемся в этом, перезаписав `issue` файл на `hostname` файл:

```
$ cd ~/linux_essentials-2.4/copying/files
$ ls
hostname  issue  nsswitch.conf
$ cat hostname
mycomputer
$ cat issue
Debian GNU/Linux 9 \n \l

$ cp hostname issue
$ cat issue
mycomputer
```

Теперь давайте попробуем создать копию каталога `files` внутри каталога `directories`:

```
$ cd ~/linux_essentials-2.4/copying
$ cp files directories
cp: omitting directory ‘files’
```

Как вы можете видеть, `cp` по умолчанию работает только с отдельными файлами. Чтобы скопировать каталог, вы используете опцию `-r`. Имейте в виду, что `-r` опция также приведет  `cp`  к копированию содержимого каталога, который вы копируете:

```
$ cp -r files directories
$ find
.
./files
./files/nsswitch.conf
./files/fstab
./files/hostname
./directories
./directories/files
./directories/files/nsswitch.conf
./directories/files/fstab
./directories/files/hostname
```

Обратите внимание, что при использовании существующего каталога в качестве целевого `cp` создает внутри него копию исходного каталога. Если целевой каталог не существует, он будет создан и заполнен содержимым исходного каталога:

```
$ cp -r files files2
$ find
.
./files
./files/nsswitch.conf
./files/fstab
./files/hostname
./directories
./directories/files
./directories/files/nsswitch.conf
./directories/files/fstab
./directories/files/hostname
./files2
./files2/nsswitch.conf
./files2/fstab
./files2/hostname
```

## &#x20;Глоббирование

То, что обычно называют глоббированием (подстановкой) , — это простой язык сопоставления шаблонов. Оболочки командной строки в системах Linux используют этот язык для обозначения групп файлов, имена которых соответствуют определённому шаблону. В стандарте POSIX.1-2017 указаны следующие символы для сопоставления шаблонов:

`*`

Соответствует любому количеству любых символов, включая отсутствие символов

`?`

Соответствует любому символу

`[]`

Соответствует классу символов

По-английски это означает, что вы можете указать оболочке, чтобы она соответствовала шаблону, а не буквальной строке текста. Обычно пользователи Linux указывают несколько файлов с помощью подстановочного знака вместо того, чтобы вводить каждое имя файла по отдельности. Выполните следующие команды:

```
$ cd ~/linux_essentials-2.4/globs
$ ls
question1 question14 question2012 star10 star2002
question13 question15 question23 star1100 star2013
$ ls star1*
star10 star1100
$ ls star*
star10 star1100 star2002 star2013
$ ls star2*
star2002 star2013
$ ls star2*2
star2002
$ ls star2013*
star2013
```

Оболочка расширяет `*` до любого количества значений, поэтому ваша оболочка интерпретирует `star*` как означающее что угодно в соответствующем контексте, начинающееся со `star`. Когда вы запускаете команду `ls star*`, ваша командная оболочка не запускает `ls` программу с аргументом `star*`, она ищет в текущем каталоге файлы, соответствующие шаблону, `star*` (включая просто `star`) и преобразует каждый файл, соответствующий шаблону, в аргумент для `ls`:

```
$ ls star*
```

что касается `ls` , то это эквивалентно:

```
$ ls star10 star1100 star2002 star2013
```

Символ `*` ничего не значит для `ls`. Чтобы доказать это, выполните следующую команду:

```
$ ls star\*
ls: cannot access star*: No such file or directory
```

Когда вы ставите перед символом знак `\`, вы инструктируете свою оболочку не интерпретировать его. В этом случае вы хотите чтобы `ls` имел аргумент `star*` вместо того, чтобы расширить `star*`.

Символ `?` расширяется до любого отдельного символа. Попробуйте следующие команды, чтобы убедиться в этом сами.:

```
$ ls
question1   question14  question2012  star10    star2002
question13  question15  question23    star1100  star2013
$ ls question?
question1
$ ls question1?
question13  question14  question15
$ ls question?3
question13  question23
$ ls question13?
ls: cannot access question13?: No such file or directory
```

`[]`Квадратные скобки используются для сопоставления диапазонов или классов символов. `[]` Скобки работают так же, как и в регулярных выражениях POSIX, за исключением того, что в глоббировании `^` используется вместо `!`.

Создайте несколько файлов для экспериментов:

```
$ mkdir brackets
$ cd brackets
$ touch file1 file2 file3 file4 filea fileb filec file5 file6 file7
```

Диапазоны, заключенные в `[]` квадратные скобки, выражаются с помощью `-`:

```
$ ls
file1  file2  file3  file4  file5  file6  file7  filea  fileb  filec
$ ls file[1-2]
file1  file2
$ ls file[1-3]
file1  file2  file3
```

Можно указать несколько диапазонов:

```
$ ls file[1-25-7]
file1  file2  file5  file6  file7
$ ls file[1-35-6a-c]
file1  file2  file3  file5  file6  filea  fileb  filec
```

Квадратные скобки также можно использовать для сопоставления определенного набора символов.

```
$ ls file[1a5]
file1 file5 filea
```

Вы также можете использовать символ `^` в качестве первого символа, чтобы выборка соответствовала всему, кроме определенных символов.

```
$ ls file[^a]
file1  file2  file3  file4  file5  file6  file7  fileb  filec
```

Последнее, что мы рассмотрим в этом уроке, - классы символов. Чтобы сопоставить класс символов, вы используете `[:classname:]`. Например, чтобы использовать класс digit, который соответствует цифрам, вы должны сделать что-то вроде этого:

```
$ ls file[[:digit:]]
file1  file2  file3  file4  file5  file6  file7
$ touch file1a file11
$ ls file[[:digit:]a]
file1  file2  file3  file4  file5  file6  file7  filea
$ ls file[[:digit:]]a
file1a
```

Глоббирование `file[[:digit:]a]`соответствует `file`, за которым следует цифра или `a`.

Поддерживаемые классы символов зависят от вашей текущей локали. POSIX требует следующие классы символов для всех локалей:

`[:alnum:]`

Буквы и цифры.

`[:alpha:]`

Заглавные или строчные буквы.

`[:blank:]`

Пробелы и табуляции.

`[:cntrl:]`

Управляющие символы, например backspace, bell, NAK, escape.

`[:digit:]`

Числительные (`0123456789`).

`[:graph:]`

Графические символы (все символы, кроме `ctrl` и пробела)

`[:lower:]`

Строчные буквы (`a-z`).

`[:print:]`

Печатные символы (`alnum`, `punct` и символ пробела).

`[:punct:]`

Знаки препинания, т.е. `!`, `&`, `"`.

`[:space:]`

Пробельные символы, например табуляция, пробелы, перевод строк.

`[:upper:]`

Заглавные буквы (`A-Z`).

`[:xdigit:]`

Шестнадцатеричные цифры (обычно `0123456789abcdefABCDEF`).

## &#x20;Упражнения с руководством

1. Учитывая следующее, выберите каталоги, которые будут созданы командой `mkdir -p /tmp/outfiles/text/today /tmp/infiles/text/today`

```
$ pwd
/tmp
$ find
.
./outfiles
./outfiles/text
```

| `/tmp`                     |   |
| -------------------------- | - |
| `/tmp/outfiles`            |   |
| `/tmp/outfiles/text`       |   |
| `/tmp/outfiles/text/today` |   |
| `/tmp/infiles`             |   |
| `/tmp/infiles/text`        |   |
| `/tmp/infiles/text/today`  |   |

2. Что `-v` делает для `mkdir`, `rm` и `cp`?
3. Что произойдёт, если вы случайно попытаетесь скопировать три файла в одной командной строке в уже существующий файл, а не в каталог?
4. Что происходит, когда вы используете `mv` для перемещения каталога в себя?
5. Как бы вы удалили все файлы в вашем текущем каталоге, которые начинаются с `old`?
6.  Какой из следующих файлов будет соответствовать шаблону `log_[a-z]_201?_*_01.txt`?

    | `log_3_2017_Jan_01.txt`       |   |
    | ----------------------------- | - |
    | `log_+_2017_Feb_01.txt`       |   |
    | `log_b_2007_Mar_01.txt`       |   |
    | `log_f_201A_Wednesday_01.txt` |   |
7.  Создайте несколько шаблонов, соответствующих следующему списку имен файлов:

    ```
    doc100
    doc200 
    doc301
    doc401
    ```

## &#x20;

## &#x20;Исследовательские упражнения

1. Используйте справочную страницу `cp`, чтобы узнать, как создать копию файла и обеспечить соответствие разрешений и времени модификации оригиналу.
2. Что делает команда `rmdir -p`? Поэкспериментируйте с ней и объясните, чем она отличается от `rm -r`.
3. **НА САМОМ ДЕЛЕ НЕ ИСПОЛЬЗУЙТЕ ЭТУ КОМАНДУ**: как вы думаете, что сделает `rm -ri /*`? (**ЧЕСТНО, НЕ ПОПЫТАЙТЕСЬ ЭТО СДЕЛАТЬ!**)
4. Можно как-либо предотвратить перезапись файлов кроме использования  `-i` аргумента вместе с командой  `mv`?
5. Объясните команду `cp -u`.

## &#x20;Краткие сведения

Среда командной строки Linux предоставляет инструменты для управления файлами. Некоторые из наиболее часто используемых инструментов — это `cp`, `mv`, `mkdir`, `rm` и `rmdir`. Эти инструменты в сочетании с шаблонами позволяют пользователям выполнять большую часть работы очень быстро.

У многих команд есть опция `-i` , которая запрашивает у вас подтверждение перед выполнением каких-либо действий. Подтверждение может избавить вас от лишних хлопот, если вы что-то неправильно набрали.

У многих команд есть параметр `-r`. Параметр `-r`, как правило, означает рекурсию. В математике и информатике рекурсивная функция — это функция, которая использует саму себя в своём определении. Когда речь идёт об инструментах командной строки, это обычно означает применение команды к каталогу и всем его содержимым.

Команды, используемые в этом уроке:

`cat`

Считывание и вывод содержимого файла.

`cp`

Копирует файлы или каталоги.

`echo`

Выводит строку.

`find`

Проходится по дереву файловой системы и находит файлы, соответствующие определённому набору критериев.

`ls`

Показывает свойства файлов и каталогов и перечисляет содержимое каталога.

`mkdir`

Создаёт новые каталоги.

`mv`

Перемещает или переименовывает файлы или каталоги.

`pwd`

Выводит текущий рабочий каталог.

`rm`

Удаляет файлы или каталоги.

`rmdir`

Удаляет каталоги.

`touch`

Создаёт новые пустые файлы или обновляет временную метку модификации существующего файла.

## &#x20;Ответы на упражнения с руководством

1. Учитывая следующее, выберите каталоги, которые будут созданы командой `mkdir -p /tmp/outfiles/text/today /tmp/infiles/text/today`

| `/tmp`                     |   |
| -------------------------- | - |
| `/tmp/outfiles`            |   |
| `/tmp/outfiles/text`       |   |
| `/tmp/outfiles/text/today` | X |
| `/tmp/infiles`             | X |
| `/tmp/infiles/text`        | X |
| `/tmp/infiles/text/today`  | X |

2. Что `-v` делает для `mkdir`, `rm` и `cp`?

Обычно `-v` включает подробный вывод. Это заставляет соответствующие программы выводить то, что они делают, так, как они это делают:

```
$ rm -v a b
removed 'a'
removed 'b'
$ mv -v a b
'a' -> 'b'
$ cp -v b c
'b' -> 'c'
```

3. Что произойдёт, если вы случайно попытаетесь скопировать три файла в одной командной строке в уже существующий файл, а не в каталог?

`cp` откажется что-либо делать и выведет сообщение об ошибке:

```
$ touch a b c d
$ cp a b c d
cp: target 'd' is not a directory
```

4. Что происходит, когда вы используете `mv` для перемещения каталога в себя?

Вы получите сообщение об ошибке, в котором говорится, что `mv` не удается этого сделать.

```
$ mv a a
mv: cannot move 'a' to a subdirectory of itself, 'a/a'
```

5. Как бы вы удалили все файлы в вашем текущем каталоге, которые начинаются с `old`?

Нужно использовать шаблон:

```
$ rm old*
```

6. Какой из следующих файлов будет соответствовать шаблону `log_[a-z]_201?_*_01.txt`?

| `log_3_2017_Jan_01.txt`       |   |
| ----------------------------- | - |
| `log_+_2017_Feb_01.txt`       |   |
| `log_b_2007_Mar_01.txt`       |   |
| `log_f_201A_Wednesday_01.txt` | X |

```
$ ls log_[a-z]_201?_*_01.txt 
log_f_201A_Wednesday_01.txt
```

`log_[a-z]` `log_` соответствует любой букве нижнего регистра, поэтому `log_f_201A_Wednesday_01.txt` и `log_b_2007_Mar_01.txt` совпадают. `_201?` соответствует любому отдельному символу, поэтому `log_f_201A_Wednesday_01.txt` совпадает. Наконец, `*_01.txt` соответствует всему, что заканчивается на `_01.txt`, поэтому наш оставшийся вариант совпадает.

7. Создайте несколько шаблонов, соответствующих следующему списку имен файлов:

```
doc100
doc200 
doc301
doc401
```

Существует несколько решений. Вот некоторые из них:

```
doc*
doc[1-4]*
doc?0?
doc[1-4]0?
```

## &#x20;Ответы на исследовательские упражнения

1. Используйте справочную страницу `cp`, чтобы узнать, как создать копию файла и обеспечить соответствие разрешений и времени модификации оригиналу.

Вы бы использовали опцию `-p`

```
$ man cp
-p     same as --preserve=mode,ownership,timestamps
--preserve[=ATTR_LIST]
              preserve the specified attributes (default: mode,ownership,time‐
              stamps), if  possible  additional  attributes:  context,  links,
              xattr, all
```

2. Что делает команда `rmdir -p`? Поэкспериментируйте с ней и объясните, чем она отличается от `rm -r`.

Это приводит к тому, что `rmdir` ведёт себя так же, как `mkdir -p`. Если передать ему дерево пустых каталогов, он удалит их все.

```
$ find
.
./a
./a/b
./a/b/c
$ rmdir -p a/b/c
$ ls
```

3. **НА САМОМ ДЕЛЕ НЕ ИСПОЛЬЗУЙТЕ ЭТУ КОМАНДУ**: как вы думаете, что сделает `rm -ri /*`? (**ЧЕСТНО, НЕ ПОПЫТАЙТЕСЬ ЭТО СДЕЛАТЬ!**)

Это приведет к удалению всех файлов и директорий, доступных для записи с помощью вашей учетной записи пользователя. Это включает любые сетевые файловые системы.

4. Можно как-либо предотвратить перезапись файлов кроме использования  `-i` аргумента вместе с командой  `mv`?

Да, опция `-n` или `--no-clobber` предотвращает перезапись файлов.

```
$ cat a
a
$ cat b
b
$ mv -n a b
$ cat b
b
```

5. Объясните команду `cp -u`.

`-u` Опция заставляет `cp` копировать файл только в том случае, если пункт назначения отсутствует или он старше исходного файла.

```
$ ls -l
total 24K
drwxr-xr-x 123 emma student  12K Feb  2 05:34 ..
drwxr-xr-x   2 emma student 4.0K Feb  2 06:56 .
-rw-r--r--   1 emma student    2 Feb  2 06:56 a
-rw-r--r--   1 emma student    2 Feb  2 07:00 b
$ cat a
a
$ cat b
b
$ cp -u a b
$ cat b
b
$ cp -u a c
$ ls -l
total 12
-rw-r--r-- 1 emma student 2 Feb  2 06:56 a
-rw-r--r-- 1 emma student 2 Feb  2 07:00 b
-rw-r--r-- 1 emma student 2 Feb  2 07:00 c
```







