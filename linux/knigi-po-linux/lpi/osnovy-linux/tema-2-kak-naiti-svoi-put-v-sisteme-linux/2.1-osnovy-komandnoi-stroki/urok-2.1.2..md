# Урок 2.1.2.





## &#x20;**Введеине**

Все оболочки управляют набором информации о состоянии во время сеансов работы оболочки. Эта информация во время выполнения может изменяться во время сеанса и влиять на поведение оболочки. Эти данные также используются программами для определения аспектов конфигурации системы. Большая часть этих данных хранится в так называемых переменных, которые мы рассмотрим в этом уроке.

## &#x20;**Переменные**

**Переменные** —это элементы памяти для хранения данных, таких как текст или числа. После установки значения переменной можно получить доступ к нему позже. Переменные имеют имя, которое позволяет получить доступ к определенной переменной, даже если ее содержимое изменяется. Они являются очень распространенным инструментом в большинстве языков программирования.

В большинстве оболочек Linux существует два типа переменных:

**Локальные переменные**

Эти переменные доступны только текущему процессу командной строки. Если вы создадите локальную переменную, а затем запустите другую программу из этой командной строки, эта переменная больше не будет доступна для этой программы. Поскольку они не наследуются подпроцессами, эти переменные называются локальными переменными.

**Переменные среды**

Эти переменные доступны как в конкретном сеансе командной строки, так и в подпроцессах, порожденных этим сеансом командной строки. Эти переменные могут использоваться для передачи данных конфигурации выполняемым командам. Поскольку эти программы могут обращаться к этим переменным, они называются переменными среды. Большинство переменных среды указаны заглавными буквами (например `PATH, DATE, USER)`. ННабор переменных среды по умолчанию предоставляет, например, информацию о домашнем каталоге пользователя или типе терминала. Иногда полный набор всех переменных среды называется окружением.

{% hint style="info" %}
Переменные не являются постоянными. Когда оболочка, в которой они были установлены, закрывается, все переменные и их содержимое теряются. Большинство оболочек предоставляют файлы конфигурации, содержащие переменные, которые устанавливаются при запуске новой оболочки. Переменные, которые должны быть установлены постоянно, должны быть добавлены в один из этих файлов конфигурации.
{% endhint %}

## &#x20;**Манипулирование переменными**

Как системному администратору, вам потребуется создавать, изменять или удалять как локальные переменные, так и переменные среды.

## &#x20;**Работа с локальными переменными**



Вы можете настроить локальную переменную, используя оператор `=` (равно). Простое назначение создаст локальную переменную:

```
$ greeting=hello
```

{% hint style="info" %}
Не ставьте пробелы перед `=`оператором или после него.
{% endhint %}



Вы можете отобразить любую переменную с помощью `echo`команды. Команда обычно отображает текст в разделе аргументов:

```
$ echo greeting
greeting
```

Чтобы получить доступ к значению переменной, вам необходимо использовать `$`(знак доллара) перед именем переменной.

```
$ echo $greeting
hello
```

Как видно, переменная создана. Теперь откройте другую оболочку и попробуйте отобразить содержимое созданной переменной.

```
$ echo $greeting
```

Ничего не отображается. Это иллюстрирует, что переменные всегда существуют только в определенной оболочке.

Чтобы проверить, что переменная на самом деле является локальной, попробуйте создать новый процесс и проверить, может ли этот процесс получить доступ к переменной. Мы можем сделать это, запустив другую оболочку и позволив этой оболочке выполнить **echo** команду. Поскольку новая оболочка запускается в новом процессе, она не унаследует локальные переменные от своего родительского процесса:

```
$ echo $greeting world
hello world
$ bash -c 'echo $greeting world'
world

```

{% hint style="info" %}
Обязательно используйте одинарные кавычки в приведенном выше примере.
{% endhint %}

Чтобы удалить переменную, вам нужно будет использовать команду **`unset`**:

```
$ echo $greeting
hey
$ unset greeting
$ echo $greeting
```

{% hint style="info" %}
**`unset`**требует имя переменной в качестве аргумента. Поэтому вы не можете добавлять `$`к имени, так как это разрешит переменную и передаст значение переменной `unset`вместо имени переменной.
{% endhint %}

## &#x20;**Работа с глобальными переменными**

Чтобы сделать переменную доступной для подпроцессов, превратите ее из локальной в переменную окружения. Это делается командой **`export`**. При вызове с именем переменной эта переменная добавляется в окружение оболочки:

```
$ greeting=hello
$ export greeting
```

{% hint style="info" %}
Опять же, не используйте `$`при запуске **`export`**, так как вы хотите передать имя переменной вместо ее содержимого.
{% endhint %}

Более простой способ создания переменной среды — объединить оба вышеперечисленных метода, присвоив значение переменной в аргументной части команды.

```
$ export greeting=hey
```

Давайте еще раз проверим, доступна ли переменная подпроцессам:

```
$ export greeting=hey
$ echo $greeting world
hey world
$ bash -c 'echo $greeting world'
hey world
```

Другой способ использования переменных окружения — использовать их перед командами. Мы можем проверить это с помощью переменной окружения **`TZ`**, которая содержит часовой пояс. Эта переменная используется командой **`date`**для определения времени часового пояса, которое нужно отобразить:

```
$ TZ=EST date
Thu 31 Jan 10:07:35 EST 2019
$ TZ=GMT date
Thu 31 Jan 15:07:35 GMT 2019
```

Вы можете отобразить все переменные среды с помощью **`env`** команды.&#x20;

## &#x20;**Переменная`PATH`​**

Переменная `PATH`является одной из важнейших переменных окружения в системе Linux. Она хранит список каталогов, разделенных двоеточием, которые содержат исполняемые программы, имеющие право выполняться из оболочки Linux.

```
$ echo $PATH 
/home/user/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

Чтобы добавить новый каталог к ​​переменной, вам нужно будет использовать знак двоеточия ( `:`).

```
$ PATH=$PATH:новый_каталог
```

Вот пример:

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
$ PATH=$PATH:/home/user/bin
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/user/bin
```

Как вы видите, `$PATH`используется в новом значении, назначенном `PATH`. Эта переменная разрешается во время выполнения команды и гарантирует, что исходное содержимое переменной сохраняется. Конечно, вы можете использовать и другие переменные в назначении:

```
$ mybin=/opt/bin 
$ PATH=$PATH:$mybin 
$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/user/bin:/opt/bin
```

С `PATH`переменной нужно обращаться осторожно, так как она имеет решающее значение для работы в командной строке. Рассмотрим следующую `PATH`переменную:

```
$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Чтобы узнать, как оболочка вызывает определенную команду, которая может быть запущена с именем команды в качестве аргумента. Мы можем, например, попытаться выяснить, где хранится nano:

```
$ which nano
/usr/bin/nano
```

Как можно видеть, `nano` исполняемый файл находится в `/usr/bin` каталоге. Давайте удалим каталог из переменной PATH и проверим, работает ли команда по-прежнему.:

```
$ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games
```

Давайте еще раз посмотрим на команду `nano`:

```
$ which nano
which: no nano in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games)
```

Как видно, команда не найдена, следовательно, не выполнена. В сообщении об ошибке также объясняется причина, по которой команда не была найдена, и в каких местах ее искали.

Давайте добавим обратно каталоги и попробуем запустить команду еще раз.

```
$ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
$ which nano
/usr/bin/nano
```

Теперь наша команда снова работает.
