# Урок 2.1.2.

## **Введеине**

Все оболочки управляют набором информации о состоянии во время сеансов работы оболочки. Эта информация во время выполнения может изменяться во время сеанса и влиять на поведение оболочки. Эти данные также используются программами для определения аспектов конфигурации системы. Большая часть этих данных хранится в так называемых переменных, которые мы рассмотрим в этом уроке.

## **Переменные**

**Переменные** —это элементы памяти для хранения данных, таких как текст или числа. После установки значения переменной можно получить доступ к нему позже. Переменные имеют имя, которое позволяет получить доступ к определенной переменной, даже если ее содержимое изменяется. Они являются очень распространенным инструментом в большинстве языков программирования.

В большинстве оболочек Linux существует два типа переменных:

**Локальные переменные**

Эти переменные доступны только текущему процессу командной строки. Если вы создадите локальную переменную, а затем запустите другую программу из этой командной строки, эта переменная больше не будет доступна для этой программы. Поскольку они не наследуются подпроцессами, эти переменные называются локальными переменными.

**Переменные среды**

Эти переменные доступны как в конкретном сеансе командной строки, так и в подпроцессах, порожденных этим сеансом командной строки. Эти переменные могут использоваться для передачи данных конфигурации выполняемым командам. Поскольку эти программы могут обращаться к этим переменным, они называются переменными среды. Большинство переменных среды указаны заглавными буквами (например `PATH, DATE, USER)`. ННабор переменных среды по умолчанию предоставляет, например, информацию о домашнем каталоге пользователя или типе терминала. Иногда полный набор всех переменных среды называется окружением.

{% hint style="info" %}
Переменные не являются постоянными. Когда оболочка, в которой они были установлены, закрывается, все переменные и их содержимое теряются. Большинство оболочек предоставляют файлы конфигурации, содержащие переменные, которые устанавливаются при запуске новой оболочки. Переменные, которые должны быть установлены постоянно, должны быть добавлены в один из этих файлов конфигурации.
{% endhint %}

## **Манипулирование переменными**

Как системному администратору, вам потребуется создавать, изменять или удалять как локальные переменные, так и переменные среды.

## **Работа с локальными переменными**

Вы можете настроить локальную переменную, используя оператор `=` (равно). Простое назначение создаст локальную переменную:

```sh
$ greeting=hello
```

{% hint style="info" %}
Не ставьте пробелы перед `=`оператором или после него.
{% endhint %}

Вы можете отобразить любую переменную с помощью `echo`команды. Команда обычно отображает текст в разделе аргументов:

```sh
$ echo greeting
greeting
```

Чтобы получить доступ к значению переменной, вам необходимо использовать `$`(знак доллара) перед именем переменной.

```sh
$ echo $greeting
hello
```

Как видно, переменная создана. Теперь откройте другую оболочку и попробуйте отобразить содержимое созданной переменной.

```sh
$ echo $greeting
```

Ничего не отображается. Это иллюстрирует, что переменные всегда существуют только в определенной оболочке.

Чтобы проверить, что переменная на самом деле является локальной, попробуйте создать новый процесс и проверить, может ли этот процесс получить доступ к переменной. Мы можем сделать это, запустив другую оболочку и позволив этой оболочке выполнить **echo** команду. Поскольку новая оболочка запускается в новом процессе, она не унаследует локальные переменные от своего родительского процесса:

```sh
$ echo $greeting world
hello world
$ bash -c 'echo $greeting world'
world

```

{% hint style="info" %}
Обязательно используйте одинарные кавычки в приведенном выше примере.
{% endhint %}

Чтобы удалить переменную, вам нужно будет использовать команду **`unset`**:

```sh
$ echo $greeting
hey
$ unset greeting
$ echo $greeting
```

{% hint style="info" %}
**`unset`**требует имя переменной в качестве аргумента. Поэтому вы не можете добавлять `$`к имени, так как это разрешит переменную и передаст значение переменной `unset`вместо имени переменной.
{% endhint %}

## **Работа с глобальными переменными**

Чтобы сделать переменную доступной для подпроцессов, превратите ее из локальной в переменную окружения. Это делается командой **`export`**. При вызове с именем переменной эта переменная добавляется в окружение оболочки:

```sh
$ greeting=hello
$ export greeting
```

{% hint style="info" %}
Опять же, не используйте `$`при запуске **`export`**, так как вы хотите передать имя переменной вместо ее содержимого.
{% endhint %}

Более простой способ создания переменной среды — объединить оба вышеперечисленных метода, присвоив значение переменной в аргументной части команды.

```sh
$ export greeting=hey
```

Давайте еще раз проверим, доступна ли переменная подпроцессам:

```sh
$ export greeting=hey
$ echo $greeting world
hey world
$ bash -c 'echo $greeting world'
hey world
```

Другой способ использования переменных окружения — использовать их перед командами. Мы можем проверить это с помощью переменной окружения **`TZ`**, которая содержит часовой пояс. Эта переменная используется командой **`date`**для определения времени часового пояса, которое нужно отобразить:

```sh
$ TZ=EST date
Thu 31 Jan 10:07:35 EST 2019
$ TZ=GMT date
Thu 31 Jan 15:07:35 GMT 2019
```

Вы можете отобразить все переменные среды с помощью **`env`** команды.&#x20;

## **Переменная`PATH`​**

Переменная `PATH`является одной из важнейших переменных окружения в системе Linux. Она хранит список каталогов, разделенных двоеточием, которые содержат исполняемые программы, имеющие право выполняться из оболочки Linux.

```sh
$ echo $PATH 
/home/user/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
```

Чтобы добавить новый каталог к ​​переменной, вам нужно будет использовать знак двоеточия ( `:`).

```sh
$ PATH=$PATH:новый_каталог
```

Вот пример:

```
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
$ PATH=$PATH:/home/user/bin
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/user/bin
```

Как вы видите, `$PATH`используется в новом значении, назначенном `PATH`. Эта переменная разрешается во время выполнения команды и гарантирует, что исходное содержимое переменной сохраняется. Конечно, вы можете использовать и другие переменные в назначении:

```sh
$ mybin=/opt/bin 
$ PATH=$PATH:$mybin 
$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/user/bin:/opt/bin
```

С `PATH`переменной нужно обращаться осторожно, так как она имеет решающее значение для работы в командной строке. Рассмотрим следующую `PATH`переменную:

```sh
$ echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Чтобы узнать, как оболочка вызывает определенную команду, которая может быть запущена с именем команды в качестве аргумента. Мы можем, например, попытаться выяснить, где хранится nano:

```sh
$ which nano
/usr/bin/nano
```

Как можно видеть, `nano` исполняемый файл находится в `/usr/bin` каталоге. Давайте удалим каталог из переменной PATH и проверим, работает ли команда по-прежнему.:

```sh
$ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games
```

Давайте еще раз посмотрим на команду `nano`:

```sh
$ which nano
which: no nano in (/usr/local/sbin:/usr/local/bin:/usr/sbin:/sbin:/bin:/usr/games)
```

Как видно, команда не найдена, следовательно, не выполнена. В сообщении об ошибке также объясняется причина, по которой команда не была найдена, и в каких местах ее искали.

Давайте добавим обратно каталоги и попробуем запустить команду еще раз.

```sh
$ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
$ which nano
/usr/bin/nano
```

Теперь наша команда снова работает.

{% hint style="info" %}
Порядок элементов в `PATH` также определяет порядок поиска. Выполняется первый соответствующий исполняемый файл, найденный при переходе по путям.
{% endhint %}

## Упражнения с руководством

1. Создайте локальную переменную `number`.
2. Создайте переменную окружения `ORDER`, используя один из двух вышеперечисленных методов.
3. Отобразите как имена переменных, так и их содержимое.
4. Каковы области действия ранее созданных переменных?

## Исследовательские упражнения

1. Создайте локальную переменную `nr_files` и назначьте количество строк, найденных в `/etc/passwd` файле. Подсказка: Изучите команду `wc` и подстановку команд и не забудьте о кавычках.
2. Создайте переменную окружения `ME`. Присвойте ей значение `USER` переменной.
3. Добавьте значение `HOME` переменной к `ME`, используя `:` разделитель. Отобразите содержимое `ME` переменной.
4. Используя приведенный выше пример даты, создайте переменную с именем `today` и назначьте дату для одного из часовых поясов.
5. Создайте другую переменную с именем `today1` и присвоите ей системную дату.

## Краткие сведения

В этой лабораторной работе вы узнали:

* Типы переменных
* Как создавать переменные
* Как манипулировать переменными

Команды, используемые в упражнениях:

**`env`**

Отобразите текущую среду.

**`echo`**

Вывод текста.

**`export`**

Сделайте локальные переменные доступными для подпроцессов.

**`unset`**

Удалите переменную.

## Ответы на упражнения с руководством

Создайте локальную переменную `number`.

```
$ number=5
```

Создайте переменную окружения `ORDER`, используя один из двух вышеперечисленных методов.

```
$ export ORDER=desc
```

```
$ echo number
number
$ echo ORDER
ORDER
$ echo $number
5
$ echo $ORDER
desc
```

Каковы области действия ранее созданных переменных?

* Областью действия локальной переменной `number` является только текущая оболочка.
* Область действия переменной среды `ORDER` — это текущая оболочка и все создаваемые ею подоболочки.

## Ответы на исследовательские упражнения

Создайте локальную переменную `nr_files` и назначьте количество строк, найденных в `/etc/passwd` файле. Подсказка: Изучите команду `wc` и замену команд и не забудьте о кавычках.

```sh
$ nr_files=`wc -l /etc/passwd`
```

Создайте переменную окружения `ME`. Присвойте `USER` переменной значение.

```sh
$ export ME= $USER
```

Добавьте значение переменной `HOME` к переменной `ME`, используя разделитель `:`. Выведите содержимое переменной `ME`.

```sh
$ ME=$ME:$HOME
$ echo $ME
user:/home/user
```

Используя приведённый выше пример с датой, создайте переменную с именем `today` и присвойте ей дату для одного из часовых поясов.

Ниже в качестве примера используются часовые пояса GMT и EST, но допустим любой выбор часового пояса.

```sh
$ today=$(TZ=GMT date)
$ echo $today
Thu 31 Jan 15:07:35 GMT 2019
```

или

```sh
$ today=$(TZ=EST date)
$ echo $today
Thu 31 Jan 10:07:35 EST 2019
```

Создайте другую переменную с именем `today1` и присвоите ей системную дату.

Предположим, что вы находитесь в GMT:

```sh
$ today1=$(date)
$ echo $today1
Thu 31 Jan 10:07:35 EST 2019
```



