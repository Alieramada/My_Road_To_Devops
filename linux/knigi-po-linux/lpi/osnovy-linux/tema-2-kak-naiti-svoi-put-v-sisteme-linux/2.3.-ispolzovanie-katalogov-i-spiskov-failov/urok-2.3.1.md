# Урок 2.3.1

## &#x20;Файлы и каталоги

Файловая система Linux похожа на файловые системы других операционных систем тем, что содержит _файлы_ и _каталоги_. Файлы содержат данные, такие как текст, понятный человеку, исполняемые программы или двоичные данные, которые используются компьютером. Каталоги используются для организации файловой системы. Каталоги могут содержать файлы и другие каталоги.

```
$ tree

Documents
├── Mission-Statement.txt
└── Reports
    └── report2018.txt

1 directory, 2 files
```

В этом примере `Documents` — это каталог, содержащий один файл (`Mission-Statement.txt`) и один _подкаталог_ (`Reports`). Каталог `Reports` в свою очередь содержит один файл с именем `report2018.txt`. Каталог `Documents` называется _родительским_ по отношению к каталогу `Reports`.

{% hint style="info" %}
Если команда `tree` недоступна в вашей системе, установите её с помощью менеджера пакетов вашего дистрибутива Linux. Чтобы узнать, как это сделать, обратитесь к уроку по управлению пакетами.
{% endhint %}

## &#x20;Имена файлов и каталогов

Имена файлов и каталогов в Linux могут содержать строчные и прописные буквы, цифры, пробелы и специальные символы. Однако, поскольку многие специальные символы имеют особое значение в оболочке Linux, рекомендуется не использовать пробелы или специальные символы при именовании файлов или каталогов. Например, для правильного ввода пробелов требуется _экранирующий символ_ `\`:

```
$ cd Mission\ Statements
```

Кроме того, обратите внимание на имя файла `report2018.txt`. Имена файлов могут содержать _суффикс_, который ставится после точки (`.`). В отличие от Windows, этот суффикс не имеет особого значения в Linux; он нужен для удобства восприятия человеком. В нашем примере `.txt` указывает на то, что это текстовый файл, хотя технически он может содержать любые данные.

## &#x20;Навигация по файловой системе

## &#x20;**Получение Текущего Местоположения**

Поскольку оболочки Linux, такие как Bash, основаны на тексте, важно помнить ваше текущее местоположение при навигации по файловой системе. Эта информация предоставляется в _командной строке_:

```
user@hostname ~/Documents/Reports $
```

Обратите внимание, что такая информация, как `user` и `hostname`, будет рассмотрена в следующих разделах. Из подсказки мы теперь знаем, что наше текущее местоположение указано в `Reports` каталоге. Аналогично, команда `pwd` будет _печатать рабочий каталог_:

```
user@hostname ~/Documents/Reports $ pwd
/home/user/Documents/Reports
```

Взаимосвязь каталогов представлена косой чертой (`/`). Мы знаем, что `Reports` это подкаталог `Documents`, который является подкаталогом `user`, который расположен в каталоге с именем `home`. `home` выглядит так,  что у него нет родительского каталога, но это совсем не так. Родительский каталог `home` называется _root_ и обозначается первой косой чертой (`/`). Мы обсудим корневой каталог в следующем разделе.

Обратите внимание, что вывод команды `pwd` немного отличается от пути, указанного в командной строке. Вместо `/home/user` в командной строке используется тильда (`~`). Тильда — это специальный символ, обозначающий домашний каталог пользователя. Более подробно об этом мы поговорим в следующем уроке.

## &#x20;**Перечисление содержимого каталога**

Содержимое текущего каталога отображается с помощью команды `ls`:

```
user@hostname ~/Documents/Reports $ ls
report2018.txt
```

Обратите внимание, что `ls` не предоставляет никакой информации о родительском каталоге. Аналогично, по умолчанию `ls` не отображает никакой информации о содержимом подкаталогов. `ls` можно “видеть” только то, что находится в текущем каталоге.

## &#x20;**Изменение текущего каталога**

Навигация в Linux в основном осуществляется с помощью `cd` команды. Она _изменяет каталог_. Используя `pwd` предыдущую команду, мы знаем, что наш текущий каталог `/home/user/Documents/Reports`. Мы можем изменить наш текущий каталог, введя новый путь:

```
user@hostname ~ $ cd /home/user/Documents
user@hostname ~/Documents $ pwd
/home/user/Documents
user@hostname ~/Documents $ ls
Mission-Statement.txt Reports
```

Из нашего нового местоположения мы можем «видеть» `Mission-Statement.txt` и наш подкаталог `Reports`, но не содержимое нашего подкаталогa. Мы можем вернуться в `Reports` следующим образом:

```
user@hostname ~/Documents $ cd Reports
user@hostname ~/Documents/Reports $ pwd
/home/user/Documents/Reports
user@hostname ~/Documents/Reports $ ls
report2018.txt
```

## &#x20;Абсолютные и относительные пути

`pwd` Команда всегда выводит _абсолютный путь_. Это означает, что путь содержит каждый шаг пути, от верхней части файловой системы (`/`) до нижней (`Reports`). Абсолютные пути всегда начинаются с `/`.

```
/
└── home
    └── user
        └── Documents
            └── Reports
```



Абсолютный путь содержит всю информацию, необходимую для доступа к `Reports` из любой точки файловой системы. Недостатком является то, что его утомительно вводить.

Второй пример (`cd Reports`) было гораздо проще ввести. Это пример _относительного пути_. Относительные пути короче, но имеют смысл только по отношению к вашему текущему местоположению. Рассмотрим такую аналогию: я прихожу к вам домой. Вы говорите мне, что ваш друг живёт по соседству. Я пойму, что это за место, потому что оно относительно моего текущего местоположения. Но если вы скажете мне это по телефону, я не смогу найти дом вашего друга. Вам нужно будет назвать мне полный адрес.

## &#x20;**Специальные относительные пути**

Оболочка Linux позволяет сокращать пути при навигации. Чтобы отобразить первые специальные пути, мы вводим команду `ls` с флагом `-a`. Этот флаг изменяет команду `ls` таким образом, что отображаются _все_ файлы и каталоги, включая скрытые:

```
user@hostname ~/Documents/Reports $ ls -a
.
..
report2018.txt
```

{% hint style="info" %}
Вы можете обратиться к странице `man` для `ls` , чтобы понять, что делает параметр `-a`&#x20;
{% endhint %}

Эта команда показала два дополнительных результата: это специальные пути. Они не представляют собой новые файлы или каталоги, а скорее представляют каталоги, которые вам уже известны:

`.`

Указывает на _текущее местоположение_ (в данном случае `Reports`).

`..`

Указывает на _родительский каталог_ (в данном случае, `Documents`).

Обычно нет необходимости использовать специальный относительный путь для текущего местоположения. Его легче и понятнее вводить`report2018.txt`, чем сам ввод `./report2018.txt`. Но у `.` есть способы использования, о которых вы узнаете в следующих разделах. Сейчас мы сосредоточимся на относительном пути к родительскому каталогу:

```
user@hostname ~/Documents/Reports $ cd ..
user@hostname ~/Documents $ pwd
/home/user/Documents
```

Наример с `cd` намного проще использовать `..` вместо абсолютного пути. Кроме того, мы можем комбинировать этот шаблон для очень быстрой навигации вверх по файловому дереву.

```
user@hostname ~/Documents $ cd ../..
$ pwd
/home
```

## &#x20;Упражнения с руководством

1. Для каждого из следующих путей определите, является ли он _абсолютным_ или _относительным_:

| `/home/user/Downloads` |   |
| ---------------------- | - |
| `../Reports`           |   |
| `/var`                 |   |
| `docs`                 |   |
| `/`                    |   |

2. Обратите внимание на следующую файловую структуру. Примечание: Каталоги заканчиваются косой чертой (`/`), когда `tree` вызывается с помощью `-F` опции. Вам потребуются повышенные привилегии, чтобы запустить `tree` команду в корневом каталоге (`/`). Следующее является примером выходных данных и не указывает на полную структуру каталогов. Используйте его, чтобы ответить на следующие вопросы:

```
$ sudo tree -F /

/
├── etc/
│   ├── network/
│   │   └── interfaces
│   ├── systemd/
│   │   ├── resolved.conf
│   │   ├── system/
│   │   ├── system.conf
│   │   ├── user/
│   │   └── user.conf
│   └── udev/
│       ├── rules.d/
│       └── udev.conf
└── home/
    ├── lost+found/
    └── user/
        └── Documents/

12 directories, 5 files
```

Пользователь вводит следующие команды:

```
$ cd /etc /udev
$ ls -a
```

Каким будет результат выполнения `ls -a` ?

3. Введите как можно более короткую команду для каждой из следующих:

*   Ваше текущее местоположение — корень (`/`). Введите команду для перехода в `lost+found` в каталоге `home` (пример):

    ```
    $ cd home/lost+found
    ```
* Ваше текущее местоположение - root (`/`). Введите команду для перехода в каталог с именем `/etc/network/`.
* Ваше текущее местоположение - `/home/user/Documents/`. Перейдите в каталог с именем `/etc/`.
* Ваше текущее местоположение - `/etc/systemd/system/`. Перейдите в каталог с именем `/home/user/`.

4. Рассмотрим следующие команды:

```
$ pwd 
/etc/udev/правила.d
$ cd ../../ systemd /user
$ cd ..
$ pwd
```

Каков результат последней `pwd` команды?

## &#x20;Исследовательские упражнения

1. Предположим, пользователь ввел следующие команды:

```
$ mkdir "this is a test"
$ ls
this is a test
```

Какая `cd` команда позволила бы вам войти в этот каталог?

2. Попробуйте ещё раз, но после ввода `cd this` нажмите клавишу TAB. Что теперь отображается в командной строке?

Это пример _автодополнения_, которое является бесценным инструментом не только для экономии времени, но и для предотвращения орфографических ошибок.

3. Попробуйте создать каталог, имя которого содержит символ `\`. Выведите имя каталога с помощью `ls` и удалите каталог.

## &#x20;Краткие сведения

На этом уроке вы узнали:

* Основы файловой системы Linux
* Разница между _родительскими_ каталогами и _подкаталогами_
* Разница между _абсолютными_ и _относительными_ путями к файлам
* Специальные относительные пути `.` и `..`
* Навигация по файловой системе с помощью `cd`
* Cвое текущее местоположение с помощью `pwd`
* Перечислите _всех_ файлов и каталогов, используя `ls -a`

В этом уроке обсуждались следующие команды:

`cd`

Изменить текущий каталог.

`pwd`

Вывести путь к текущему рабочему каталогу

`ls`

Перечислить содержимое каталога и отобразить свойства файлов

`mkdi`

Создать новый каталог

`tree`

Отображение иерархического списка дерева каталогов

## &#x20;Ответы на упражнения с руководством

1. Для каждого из следующих путей определите, является ли он _абсолютным_ или _относительным_:

| `/home/user/Downloads` | абсолютный    |
| ---------------------- | ------------- |
| `../Reports`           | относительный |
| `/var`                 | абсолютный    |
| `docs`                 | относительный |
| `/`                    | абсолютный    |

2. Обратите внимание на следующую файловую структуру. Примечание: Каталоги заканчиваются косой чертой (`/`), когда `tree` вызывается с помощью `-F` опции. Вам потребуются повышенные привилегии, чтобы запустить `tree` команду в корневом каталоге (`/`). Следующее является примером вывода и не указывает на полную структуру каталогов. Используйте его, чтобы ответить на следующие вопросы:

<pre><code><strong>$ sudo tree -F /
</strong>
/
├── etc/
│   ├── network/
│   │   └── interfaces
│   ├── systemd/
│   │   ├── resolved.conf
│   │   ├── system/
│   │   ├── system.conf
│   │   ├── user/
│   │   └── user.conf
│   └── udev/
│       ├── rules.d/
│       └── udev.conf
└── home/
    ├── lost+found/
    └── user/
        └── Documents/

12 directories, 5 files
</code></pre>

Пользователь вводит следующие команды:

```
$ cd /etc /udev
$ ls -a
```

Каким будет результат выполнения `ls -a` команды?

```
. .. rules.d udev.conf
```

3. Введите как можно более короткую команду для каждой из следующих:
