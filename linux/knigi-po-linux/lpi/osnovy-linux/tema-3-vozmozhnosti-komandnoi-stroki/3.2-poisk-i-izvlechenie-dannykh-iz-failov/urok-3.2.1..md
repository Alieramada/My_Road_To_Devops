# Урок 3.2.1.

## Введение <a href="#sec.3.2_01-in" id="sec.3.2_01-in"></a>

В этом уроке мы сосредоточимся на перенаправлении или передаче информации из одного источника в другой с помощью специальных инструментов. Командная строка Linux перенаправляет информацию по определённым стандартным каналам. Стандартным вводом (_stdin_ или канал 0) считается клавиатура, а стандартным выводом (_stdout_ или канал 1) — экран. Существует также ещё один канал, предназначенный для перенаправления вывода ошибок (_stderr_ или канал 2)  или сообщений об ошибках программы. Входные и / или выходные данные могут быть перенаправлены.

При выполнении команды иногда требуется передать ей определённую информацию или перенаправить вывод в конкретный файл. Каждая из этих функций будет рассмотрена в следующих двух разделах.

## &#x20;Перенаправление ввода-вывода <a href="#io_redirection" id="io_redirection"></a>

Перенаправление ввода-вывода позволяет пользователю перенаправлять информацию из команды или в команду с помощью текстового файла. Как было описано ранее, можно перенаправлять стандартный ввод, вывод и ошибки, а также получать информацию из текстовых файлов.

## Перенаправление стандартного вывода <a href="#io_redirection" id="io_redirection"></a>

Чтобы перенаправить стандартный вывод в файл, а не на экран, нужно использовать оператор `>` с указанием имени файла. Если файл не существует, будет создан новый, в противном случае информация перезапишет существующий файл.

Чтобы просмотреть содержимое только что созданного файла, мы можем использовать команду `cat` . По умолчанию эта команда выводит содержимое файла на экран. Чтобы узнать больше о её функциях, обратитесь к справочному руководству.

Приведённый ниже пример демонстрирует функциональность оператора. В первом случае создаётся новый файл с текстом “Hello World!”:

```bash
$ echo "Hello World!" > text
$ cat text
Hello World!
```

При втором вызове содержимое файла перезаписывается новым текстом:

```bash
$ echo "Hello!" > text
$ cat text
Hello!
```

Если мы хотим добавить новую информацию в конец файла, нам нужно использовать оператор `>>` . Этот оператор также создаёт новый файл, если не может найти существующий.

В первом примере показано добавление текста. Как видно, новый текст был добавлен в следующую строку:

```bash
$ echo "Hello to you too!" >> text
$ cat text
Hello!
Hello to you too!
```

Второй пример демонстрирует, что будет создан новый файл:

```bash
$ echo "Hello to you too!" >> text2
$ cat text2
Hello to you too!
```

## Перенаправление стандарной ошибки

Чтобы перенаправить только сообщения об ошибках, пользователю нужно использовать оператор `2>` и указать имя файла, в который будут записываться ошибки. Если файл не существует, будет создан новый, в противном случае файл будет перезаписан.

Как уже объяснялось, канал для перенаправления стандартной ошибки — _канал 2_. При перенаправлении стандартной ошибки необходимо указать канал, в отличие от другого стандартного вывода, где _канал 1_ задаётся по умолчанию. Например, следующая команда ищет файл или каталог с именем `games` и записывает только ошибку в файл `text-error` и выводит стандартный вывод на экран:

```bash
$ find /usr games 2> text-error
/usr
/usr/share
/usr/share/misc
---------Omitted output----------
/usr/lib/libmagic.so.1.0.0
/usr/lib/libdns.so.81
/usr/games
$ cat text-error
find: `games': No such file or directory
```

{% hint style="info" %}
Для получения дополнительной информации о `find` команде обратитесь к ее справочной странице.
{% endhint %}

Например, следующая команда будет выполнена без ошибок, поэтому в файл `text-error` не будет записана никакая информация:

```bash
$ sort /etc/passwd 2> text-error
$ cat text-error
```

Помимо стандартного вывода, стандартная ошибка также может быть добавлена в файл с помощью оператора `2>>` . Это добавит новую ошибку в конец файла. Если файл не существует, будет создан новый. В первом примере показано добавление новой информации в файл, а во втором примере показано, что команда создаёт новый файл, если не может найти существующий с таким же именем:

```bash
$ sort /etc 2>> text-error
$ cat text-error
sort: read failed: /etc: Is a directory
```

```bash
$ sort /etc/shadow 2>> text-error2
$ cat text-error2
sort: open failed: /etc/shadow: Permission denied
```

При использовании этого типа перенаправления в файл будут перенаправляться только сообщения об ошибках, а обычный вывод будет отображаться на экране или проходить через стандартный вывод или _stdout_.

Существует один конкретный файл, который технически является _**битовой корзиной**_ (файлом, который принимает ввод и ничего с ним не делает): `/dev/null`. Вы можете перенаправить любую ненужную информацию, которую вы не хотите отображать, в этот файл, как показано в примере ниже:

```bash
sort /etc 2> /dev/null
```

## Перенаправление стандартного ввода

Этот тип перенаправления используется для ввода данных в команду из указанного файла, а не с клавиатуры. В этом случае используется оператор `<`, как показано в примере:

```bash
$ cat < text
Hello!
Hello to you too!
```

Перенаправление стандартного ввода обычно используется с командами, которые не принимают файлы в качестве аргументов. Одна из таких команд — `tr` . Эту команду можно использовать для преобразования содержимого файла путём изменения символов в файле определённым образом, например, для удаления какого-либо символа из файла. В приведённом ниже примере показано удаление символа `l`:

```bash
$ tr -d "l" < text
Heo!
Heo to you too!
```

{% hint style="info" %}
Для получения дополнительной информации обратитесь к справочной странице `tr`.
{% endhint %}

## &#x20;Here Document (нейросети говорят переводить как здесь документ, я такого определения в русской литературе не встречал. Слышал понятие внутренний документ, но вроде бы это более широкое понятие. Так же нашёл определение встроенный документ - в русскоязычной литературе это синоним HereDoc но в англоязычной это вроде как относится к встроенным командам и их документации в дальнейшем буду использовать HereDoc)

В отличие от перенаправления вывода, оператор `<<` работает иначе, чем другие операторы. Этот поток ввода также называется HereDoc. **HereDoc** представляет собой блок кода или текста, который может быть перенаправлен в команду или интерактивную программу. Различные типы языков сценариев, такие как `bash`, `sh` и `csh`, могут принимать ввод непосредственно из командной строки без использования текстовых файлов.

Как видно из приведённого ниже примера, оператор используется для ввода данных в команду, а слово после него не указывает на имя файла. Слово интерпретируется как разделитель ввода и не учитывается как содержимое, поэтому `cat` не будет его отображать:

```bash
$ cat << hello
> hey
> ola
> hello
hey
ola
```

{% hint style="info" %}
Обратитесь к справочной странице cat команды, чтобы найти дополнительную информацию.
{% endhint %}

## &#x20;Комбинации

Первая комбинация, которую мы рассмотрим, объединяет перенаправление стандартного вывода и стандартного вывода ошибок в один и тот же файл. Используются операторы `&>` и `&>>`, `&` представляющие собой комбинацию _канала 1_ и _канала 2_. Первый оператор перезапишет существующее содержимое файла, а второй добавит новую информацию в конец файла. Оба оператора позволят создать новый файл, если он не существует, как и в предыдущих разделах:

```sh
$ find /usr admin &> newfile
$ cat newfile
/usr
/usr/share
/usr/share/misc
---------Omitted output----------
/usr/lib/libmagic.so.1.0.0
/usr/lib/libdns.so.81
/usr/games
find: `admin': No such file or directory
$ find /etc/calendar &>> newfile
$ cat newfile
/usr
/usr/share
/usr/share/misc
---------Omitted output----------
/usr/lib/libmagic.so.1.0.0
/usr/lib/libdns.so.81
/usr/games
find: `admin': No such file or directory
/etc/calendar
/etc/calendar/default
```

Давайте рассмотрим пример использования команды `cut`:

```sh
$ cut -f 3 -d "/" newfile
$ cat newfile

share
share
share
---------Omitted output----------
lib
games
find: `admin': No such file or directory
calendar
calendar
find: `admin': No such file or directory
```

Команда `cut` вырезает указанные поля из входного файла с помощью опции `-f` — в нашем случае это 3-е поле. Чтобы команда могла найти поле, необходимо также указать разделитель с помощью опции `-d` . В нашем случае разделителем будет символ `/` .

## Конвейеры (Pipping)

Перенаправление в основном используется для сохранения результата выполнения команды, чтобы его можно было обработать другой командой. Такой промежуточный процесс может стать очень утомительным и сложным, если вы хотите, чтобы данные прошли через несколько процессов. Чтобы избежать этого, вы можете напрямую связать команды с помощью pipes. Другими словами, вывод первой команды автоматически становится вводом для второй команды. Это соединение создаётся с помощью оператора `|` (вертикальная черта):

```sh
$ cat /etc/passwd | less
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
:
```

В приведённом выше примере команда `less` после оператора | изменяет способ отображения файла. Команда `less` отображает текстовый файл, позволяя пользователю прокручивать его вверх и вниз по строкам. `less` также используется по умолчанию для отображения справочных страниц, как обсуждалось в предыдущих уроках.

Можно использовать несколько каналов одновременно. Промежуточные команды, которые получают входные данные, изменяют их и выдают выходные данные, называются _фильтрами_. Давайте возьмём команду `ls -l` и попробуем подсчитать количество слов в первых 10 строках вывода. Для этого нам нужно использовать команду `head` , которая по умолчанию выводит первые 10 строк файла, а затем подсчитать количество слов с помощью команды `wc`&#x20;

```shell
$ ls -l | head | wc -w 
10
```

Как упоминалось ранее, по умолчанию `head` отображает только первые 10 строк указанного текстового файла. Это поведение можно изменить с помощью специальных параметров. Чтобы узнать больше, <mark style="background-color:orange;">**обратитесь к справочной странице команды.**</mark>

Есть ещё одна команда, которая отображает конец файла: `tail`. По умолчанию эта команда выбирает последние 10 строк и отображает их, но, как и в случае с `head` количество строк можно изменить. <mark style="background-color:orange;">**Подробнее см. на странице**</mark><mark style="background-color:orange;">** **</mark><mark style="background-color:orange;">**`tail`**</mark><mark style="background-color:orange;">** **</mark><mark style="background-color:orange;">**man.**</mark>

{% hint style="info" %}
Опция `-f` может отображать последние строки файла во время его обновления. Эта функция может быть очень полезна при отслеживании текущей активности в файле, например, `syslog`
{% endhint %}

Команда `wc` (подсчёт слов) по умолчанию подсчитывает строки, слова и байты в файле. Как показано в упражнении, опция `-w` заставляет команду подсчитывать только слова в выбранных строках. Наиболее распространённые опции, которые можно использовать с этой командой: `-l`, которая указывает команде подсчитывать только строки, и `-c`, которая используется для подсчёта только байтов. Другие варианты и опции команды, а также дополнительную информацию о `wc` можно найти в справочной странице команды.

## Упражнения с руководством <a href="#sec.3.2_01-ge" id="sec.3.2_01-ge"></a>

1. Выведите список содержимого текущего каталога, включая владельца и права доступа, и перенаправьте вывод в файл с именем `contents.txt` в вашем домашнем каталоге.
2. Отсортируйте содержимое файла `contents.txt` из вашего текущего каталога и добавьте его в конец нового файла с именем `contents-sorted.txt`.
3. Выведите последние 10 строк файла `/etc/passwd` и перенаправьте их в новый файл в каталоге `Documents` вашего пользователя.
4. Подсчитайте количество слов в файле `contents.txt` и добавьте результат в конец файла `field2.txt` в вашем домашнем каталоге. Вам нужно будет использовать перенаправление ввода и вывода.
5. Выведите первые 5 строк файла `/etc/passwd` и отсортируйте вывод в обратном алфавитном порядке.
6. Используя ранее созданный файл `contents.txt`, посчитайте количество символов в последних 9 строках.
7. Подсчитайте количество файлов с именем `test` в каталоге `/usr/share` и его подкаталогах. Примечание: каждая строка в выводе команды `find` представляет собой файл.

## Исследовательские упражнения <a href="#sec.3.2_01-ee" id="sec.3.2_01-ee"></a>

1. Выберите второе поле в файле `contents.txt` и перенаправьте стандартный вывод и вывод ошибок в другой файл под названием `field1.txt`.
2. Используя оператор перенаправления ввода и команду `tr`, удалите тире (`-`) из файла `contents.txt`
3. В чем самое большое преимущество перенаправления ошибок только в файл?
4. Замените все повторяющиеся пробелы в файле `contents.txt` с алфавитным порядком на один пробел.
5. В одной командной строке удалите повторяющиеся пробелы (как в предыдущем упражнении), выберите девятое поле и отсортируйте его в обратном алфавитном порядке без учёта регистра. Сколько символов вам пришлось использовать?

## Краткие сведения <a href="#sec.3.2_01-su" id="sec.3.2_01-su"></a>

В этой лабораторной работе вы узнали:

* Типы перенаправления
* Как использовать операторы перенаправления
* Как использовать каналы для фильтрации выходных данных команды

Команды, используемые в этом уроке:

`cut`

Удаляет разделы из каждой строки файла.

`cat`

Отображает или объединяет файлы.

`find`

Выполняет поиск файлов в иерархии каталогов.

`less`

Отображает файл, позволяя пользователю прокручивать одну строку за раз.

`more`

Отображает файл, страницу в данный момент времени.

`head`

Отображает первые 10 строк файла.

`tail`

Отображает последние 10 строк файла.

`sort`

Сортировка файлов.

`wc`

По умолчанию подсчитываются строки, слова или байты файла.

### Ответы на упражнения с руководством <a href="#sec.3.2_01-age" id="sec.3.2_01-age"></a>

1.  Выведите список содержимого текущего каталога, включая владельца и права доступа, и перенаправьте вывод в файл с именем `contents.txt` в вашем домашнем каталоге.

    <pre class="language-bash"><code class="lang-bash"><strong>$ ls -l > contents.txt 
    </strong></code></pre>
2.  Отсортируйте содержимое файла `contents.txt` из вашего текущего каталога и добавьте его в конец нового файла с именем `contents-sorted.txt`.

    ```bash
    $ sort contents.txt >> contents-sorted.txt
    ```
3.  Выведите последние 10 строк файла `/etc/passwd` и перенаправьте их в новый файл в каталоге `Documents` вашего пользователя.

    <pre class="language-bash"><code class="lang-bash"><strong>$ tail /etc/passwd > Documents/newfile
    </strong></code></pre>
4.  Подсчитайте количество слов в файле `contents.txt` и добавьте результат в конец файла `field2.txt` в вашем домашнем каталоге. Вам нужно будет использовать перенаправление ввода и вывода.

    <pre class="language-bash"><code class="lang-bash"><strong>$ wc &#x3C; contents.txt >> field2.txt
    </strong></code></pre>
5.  Выведите первые 5 строк файла `/etc/passwd` и отсортируйте вывод в обратном алфавитном порядке.

    <pre class="language-bash"><code class="lang-bash"><strong>$ head -n 5 /etc/passwd | sort -r
    </strong></code></pre>
6.  Используя ранее созданный файл `contents.txt`, посчитайте количество символов в последних 9 строках.

    <pre><code><strong>$ tail -n 9 contents.txt | wc -c
    </strong>531
    </code></pre>
7.  Подсчитайте количество файлов с именем `test` в каталоге `/usr/share` и его подкаталогах. Примечание: каждая строка в выводе команды `find` представляет собой файл.

    <pre class="language-bash"><code class="lang-bash"><strong>$ найти в /usr/share файл с именем test | wc -l
    </strong>125
    </code></pre>

## Ответы на исследовательские упражнения <a href="#sec.3.2_01-aee" id="sec.3.2_01-aee"></a>

1.  Выберите второе поле в файле `contents.txt` и перенаправьте стандартный вывод и вывод ошибок в другой файл под названием `field1.txt`.

    ```bash
    $ cut -f 2 -d " " contents.txt &> field1.txt
    ```
2.  Используя операнд перенаправления ввода и команду `tr`, удалите тире (`-`) из файла `contents.txt`.

    <pre class="language-bash"><code class="lang-bash"><strong>$ tr -d "-" &#x3C; contents.txt
    </strong></code></pre>
3.  В чем самое большое преимущество перенаправления ошибок только в файл?

    Только перенаправление ошибок в файл может помочь в ведении часто просматриваемого журнала.
4.  Замените все повторяющиеся пробелы в файле `contents.txt` с алфавитным порядком на один пробел.

    ```bash
    $ sort contents.txt | tr -s " "
    ```
5.  В одной командной строке удалите повторяющиеся пробелы (как в предыдущем упражнении), выберите девятое поле и отсортируйте его в обратном алфавитном порядке без учёта регистра. Сколько символов вам пришлось использовать?

    <pre class="language-bash"><code class="lang-bash"><strong>$ cat contents.txt | tr -s " " | cut -f 9 -d " " | sort -fr
    </strong></code></pre>

    В упражнении используются 3 pipe , по одной для каждого фильтра.
