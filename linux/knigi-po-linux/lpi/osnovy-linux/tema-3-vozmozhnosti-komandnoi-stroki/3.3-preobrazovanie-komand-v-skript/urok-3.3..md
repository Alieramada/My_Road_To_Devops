# Урок 3.3.

## Введение <a href="#sec.3.3_01-in" id="sec.3.3_01-in"></a>

До сих пор мы учились выполнять команды из оболочки, но мы также можем вводить команды в файл, а затем сделать этот файл исполняемым. При выполнении файла эти команды запускаются одна за другой. Такие исполняемые файлы называются _скриптами_, и они являются важнейшим инструментом для любого системного администратора Linux. По сути, мы можем рассматривать Bash как язык программирования, а также как оболочку.

## Вывод на печать <a href="#printing_output" id="printing_output"></a>

Давайте начнём с демонстрации команды, которую вы, возможно, видели в предыдущих уроках: `echo` выводит аргумент в стандартный вывод.

```sh
$ echo "Hello World!"
Hello World
```

Теперь мы воспользуемся перенаправлением файлов, чтобы отправить эту команду в новый файл под названием `new_script`.

```sh
$ echo 'echo "Hello World!"' > new_script
$ cat new_script
echo "Hello World!"
```

Файл `new_script` теперь содержит ту же команду, что и раньше.

## Создание исполняемого скрипта <a href="#making_a_script_executable" id="making_a_script_executable"></a>

Давайте продемонстрируем некоторые шаги, необходимые для того, чтобы этот файл работал так, как мы ожидаем. Первой мыслью пользователя может быть просто ввести название скрипта, как он ввёл бы название любой другой команды:

```sh
$ new_script
/bin/bash: new_script: command not found
```

Мы можем с уверенностью предположить, что `new_script` существует в нашем текущем местоположении, но обратите внимание, что сообщение об ошибке говорит нам не о том, что _**файл**_ не существует, а о том, что _**команда**_ не существует. Было бы полезно обсудить, как Linux обрабатывает команды и исполняемые файлы.

## Команды и `PATH` <a href="#commands_and_path" id="commands_and_path"></a>

Например, когда мы вводим в оболочку команду `ls` мы запускаем файл с именем `ls`, который существует в нашей файловой системе. Вы можете убедиться в этом, используя `which`:

```
$ which ls
/bin/ls
```

Было бы утомительно каждый раз вводить абсолютный путь к `ls` при просмотре содержимого каталога, поэтому в Bash есть _**переменная среды**_, которая содержит все каталоги, в которых мы можем найти команды, которые хотим запустить. Вы можете просмотреть содержимое этой переменной с помощью `echo`.

```sh
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

В каждом из этих мест оболочка ожидает найти команду, каталоги разделённы двоеточиями (`:`). Вы заметите, что каталог `/bin` присутствует, но можно с уверенностью предположить, что нашего текущего каталога в этой переменной нет. Оболочка будет искать `new_script` в каждом из этих каталогов, но не найдёт его и поэтому выдаст ошибку, которую мы видели выше.

Есть три способа решить эту проблему: мы можем переместить `new_script` в один из `PATH` каталогов, мы можем добавить текущий каталог в `PATH`  переменную или изменить способ вызова скрипта. Последний способ самый простой, он требует лишь указать _**текущее местоположение**_ при вызове скрипта с помощью косой черты (`./`).

```sh
$ ./new_script
/bin/bash: ./new_script: Permission denied
```

Сообщение об ошибке изменилось, что указывает на то, что мы добились некоторого прогресса.

