# Глава 3. Модульное тестирование - Введение в систему модульного тестирования

Тестирование вашего проекта - неотъемлемая часть разработки программного обеспечения. В этой главе мы познакомимся с модульным тестированием на Python. В Python есть модуль под названием unit test, который представляет собой платформу модульного тестирования.&#x20;

В этой главе вы ознакомитесь со следующими темами:

* Введение в платформу модульного тестирования&#x20;
* Создание задач модульного тестирования

## Что такое модуль unit test?

unit test - это фреймворк модульного тестирования на Python. Он поддерживает множество задач, таких как создание тестовых наборов, написание тестовых примеров, объединение тестовых примеров в наборы тестов и выполнение тестов.

unittest поддерживает четыре основные концепции, которые перечислены здесь:

* test fixture: включает в себя действия по подготовке и очистке для выполнения одного или нескольких тестов
* test case: включает в себя ваш индивидуальный модульный тест. Используя базовый класс unittesta - TestCase, мы можем создавать новые тестовые наборы
* test suite: Он включает в себя набор тестовых наборов, наборы тестов или и то, и другое. Это предназначено для совместного выполнения тестовых наборов
* test runner: Включает в себя организацию выполнения тестов и предоставление результатов пользователям

В Python есть модуль unittest, который мы импортируем в наш скрипт. В модуле unittest есть класс TestCase для создания тестовых наборов.

Отдельные тестовые наборы могут быть созданы в виде методов. Названия этих методов начинаются со слова test. Таким образом, test runner будет знать, какие методы представляют собой тестовые примеры. test runner включает в себя организацию выполнения теста и предоставление результатов пользователям.

## Создание модульных тестов

В этом разделе мы собираемся создать модульные тесты. Для этого мы создадим два скрипта. Один будет вашим обычным скриптом, а другой будет содержать код для тестирования.

Сначала создайте скрипт с именем arithmetic.py и напишите в нем следующий код:

```python
# In this script, we are going to create a 4 functions: add_numbers, sub_numbers, mul_numbers, div_numbers.
def add_numbers(x, y):
    return x + y

def sub_numbers(x, y):
    return x - y

def mul_numbers(x, y):
    return x * y

def div_numbers(x, y):
    return (x / y)
```

В предыдущем скрипте мы создали четыре функции: add\_numbers, sub\_numbers, hull\_numbers и dev\_numbers. Теперь мы собираемся написать тестовые примеры для этих функций. Сначала мы узнаем, как мы можем написать тестовые примеры для функции add\_numbers. Создайте test\_addition.py скрипт и напишите:

```python
import arithmetic
import unittest

# Testing add_numbers function from arithmetic.
class Test_addition(unittest.TestCase):
    # Testing Integers            
    def test_add_numbers_int(self):
        sum = arithmetic.add_numbers(50, 50)
        self.assertEqual(sum, 100)
    
    # Testing Floats
    def test_add_numbers_float(self):
        sum = arithmetic.add_numbers(50.55, 78)
        self.assertEqual(sum, 128.55)

    # Testing Strings
    def test_add_numbers_strings(self):
        sum = arithmetic.add_numbers('hello','python')
        self.assertEqual(sum, 'hellopython')

if __name__ == '__main__':
    unittest.main()
```

В предыдущем скрипте мы написали три тестовых примера для функции add\_numbers. Первый предназначен для тестирования целых чисел, второй - для тестирования чисел с плавающей точкой, а третий - для тестирования строк. В strings сумма означает конкатенацию двух строк. Аналогичным образом вы можете написать тестовые примеры для вычитания, умножения и деления.

Теперь мы запустим наш тестовый скрипт test\_addition.py и посмотрим, какой результат мы получим после запуска этого скрипта.

Запустите скрипт следующим образом, и вы получите следующий результат:

```bash
student@ubuntu:~$ python3 test_addition.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s
 
OK
```

Мы получили сообщение "ОК", что означает, что наше тестирование прошло успешно.

Всякий раз, когда вы запускаете свой тестовый скрипт, у вас есть три возможных результата тестирования:

| **Result** | **Description**                                       |
| ---------- | ----------------------------------------------------- |
| OK         | Успешно                                               |
| FAIL       | Тест не пройден – возникает исключение AssertionError |
| ERROR      | Вызывает исключение, отличное от AssertionError       |

## Методы, используемые в модульном тестировании

Всякий раз, когда мы используем unittest, в нашем скрипте мы используем несколько методов:

* assertEqual() и assertNotEqual(): Проверяет ожидаемый результат&#x20;
* assertTrue() и assertFalse(): Проверяет условие
* assertRaises(): Проверяет, возникает ли конкретное исключение
* setUp() и tearDown(): Определяет инструкции, которые выполняются до и после каждого метода тестирования

Вы также можете использовать модуль unittest из командной строки. Итак, вы можете запустить предыдущий тестовый скрипт следующим образом:

```bash
student@ubuntu:~$ python3 -m unittest test_addition.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s
 
OK
```

Теперь мы рассмотрим другой пример. Мы создадим два скрипта: if\_example.py и test\_if.py. if\_example.py будет наш обычный скрипт и test\_if.py будет содержать тестовый пример. В этом тесте мы проверяем, равно ли введенное число 100 или нет. Если оно равно 100, то наш тест будет успешным. Если нет, то он должен показать неудачный результат.

Создайте скрипт if\_example.py и напишите в нем следующий код:

```python
def check_if():
    a = int(input("Enter a number \n"))
    if (a == 100):
        print("a is equal to 100")
    
    else:
        print("a is not equal to 100")
    
    return a
```

Теперь создайте тестовый скрипт test\_if.py и напишите в нем следующий код:

```python
import if_example
import unittest

class Test_if(unittest.TestCase):
    def test_if(self):
        result = if_example.check_if()
        self.assertEqual(result, 100)
        if __name__ == '__main__':
    unittest.main()
```

Запустите тестовый скрипт следующим образом:

```bash
student@ubuntu:~/Desktop$ python3 -m unittest test_if.py
Enter a number
100
a is equal to 100
.
----------------------------------------------------------------------
Ran 1 test in 1.912s 

OK
```

Мы запускаем скрипт для получения успешного результата тестирования. Теперь мы введем какое-либо значение, отличное от 100, и мы должны получить НЕУДАЧНЫЙ результат. Запустите скрипт следующим образом:

```bash
student@ubuntu:~/Desktop$ python3 -m unittest test_if.py
Enter a number
50
a is not equal to 100
F
======================================================================
FAIL: test_if (test_if.Test_if)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/student/Desktop/test_if.py", line 7, in test_if
    self.assertEqual(result, 100)
AssertionError: 50 != 100
 
----------------------------------------------------------------------
Ran 1 test in 1.521s

FAILED (failures=1)
```

## Итоги

В этой главе мы узнали о модульном тестировании unittest, которое представляет собой платформу модульного тестирования Python. Мы также узнали о том, как создавать тестовые примеры и методы, используемые в модульном тестировании.

В следующей главе мы узнаем, как автоматизировать обычную административную деятельность системного администратора. Вы узнаете о том, как принимать входные данные, обрабатывать пароли, выполнять внешние команды, читать конфигурационные файлы, добавлять предупреждающие коды в скрипты, устанавливать ограничения на использование ресурсов процессора, запускать веб-браузер, использовать модуль операционной системы и создавать резервные копии.

## Вопросы&#x20;

Что такое модульное тестирование, автоматизированное тестирование и ручное тестирование?&#x20;

**Модульное тестирование (юнит-тестирование)** — это процесс проверки отдельных модулей или компонентов программы на корректность работы. В контексте Python модульное тестирование позволяет убедиться, что каждый модуль или функция работают правильно и соответствуют требованиям.

**Автоматизированное тестирование** — это использование специальных инструментов для автоматического выполнения тестов. Автоматизированные тесты могут быть написаны с использованием различных фреймворков и библиотек, таких как pytest, unittest и других. Эти инструменты позволяют быстро и эффективно проверять работу кода, а также облегчают процесс рефакторинга и обновления кода.

В контексте Python автоматизированное тестирование может включать в себя:

* написание тестовых сценариев;
* использование фреймворка для автоматизации тестирования;
* запуск тестов и анализ результатов.

Автоматизированное тестирование помогает обеспечить стабильность и надёжность кода, а также сократить время на ручное тестирование.

**Ручное тестирование** — это проверка работы программы вручную, без использования автоматических инструментов. Ручное тестирование включает в себя выполнение различных сценариев использования программы, проверку функциональности, поиск ошибок и дефектов.

Ручное тестирование требует больше времени и усилий, чем автоматизированное, но оно может быть полезным для проверки сложных сценариев и пользовательского опыта.

Важно отметить, что автоматизированное и ручное тестирование дополняют друг друга и могут использоваться совместно для обеспечения высокого качества программного продукта.

Какие существуют альтернативные модули, помимо unittest?&#x20;

Помимо модуля unittest, существуют и другие альтернативные модули для модульного тестирования в Python. Вот некоторые из них:

1. **pytest** — это популярный фреймворк для тестирования, который предлагает более простой и гибкий синтаксис по сравнению с unittest. Pytest поддерживает параметризованные тесты, фикстуры (fixtures) и многое другое.
2. **nose** — ещё один фреймворк, который может быть использован для написания тестов. Nose предоставляет дополнительные функции, такие как поддержка плагинов, автоматическое обнаружение тестов и т. д.
3. **doctest** — модуль, предназначенный для проверки примеров кода, которые могут быть включены в документацию. Doctest позволяет автоматически проверять примеры кода в документации на корректность.
4. **behave** — фреймворк BDD (Behavior Driven Development), который помогает писать тесты на основе сценариев использования. Behave подходит для проектов, где важно описать поведение системы через сценарии.
5. **hypothesis** — библиотека для генерации тестовых данных и написания тестов, основанных на свойствах данных. Hypothesis помогает находить скрытые ошибки в коде.

Это лишь некоторые из альтернативных модулей для тестирования в Python. Выбор конкретного модуля зависит от ваших потребностей и предпочтений.

Какой смысл в написании тестовых примеров?&#x20;

Написание тестовых примеров имеет несколько важных целей:

1. **Проверка функциональности.** Тестовые примеры позволяют убедиться, что код работает правильно и выполняет требуемые функции. Это помогает предотвратить ошибки и проблемы в будущем.
2. **Обнаружение ошибок.** Тестирование выявляет ошибки в коде, которые могут привести к сбоям или неправильному поведению программы. Чем больше тестовых случаев, тем больше вероятность обнаружения ошибок.
3. **Рефакторинг и обновление.** Тестовые случаи служат основой для рефакторинга кода и его обновления. Они позволяют вносить изменения в код, не нарушая его функциональность.
4. **Документация.** Хорошо написанные тестовые примеры могут служить документацией для других разработчиков, объясняя, как должен работать код.
5. **Уверенность в качестве.** Наличие обширного набора тестов даёт уверенность в том, что программа работает корректно и соответствует требованиям.
6. **Автоматизация тестирования.** Автоматизированные тесты помогают быстро проверять изменения в коде и обеспечивают непрерывное тестирование.
7. **Улучшение качества кода.** Процесс написания тестов заставляет разработчиков более тщательно продумывать структуру кода, делать его более модульным и легко тестируемым.

В целом, написание тестовых примеров является важным этапом разработки программного обеспечения, который помогает обеспечить высокое качество продукта и уверенность в его надёжности.

Что такое стандарты PEP8?

PEP 8 — это руководство по написанию кода на Python, разработанное для того, чтобы улучшить читаемость и согласованность кода. Оно содержит рекомендации по стилю оформления кода, включая отступы, пробелы, комментарии, имена переменных, функций и классов.

PEP 8 является одним из стандартов кодирования в сообществе Python и широко используется при разработке проектов на этом языке. Соблюдение рекомендаций PEP 8 помогает сделать код более понятным и удобным для сопровождения другими разработчиками.

## Дальнейшее чтение

* Документация по модульному тестированию: [https://docs.python.org/3/library/unittest.html ](https://docs.python.org/3/library/unittest.html)
* Стандарты PEP8 на Python: [https://www.python.org/dev/peps/pep-0008/ ](https://www.python.org/dev/peps/pep-0008/)



