# Парсинг аргументов командной строки



В этом разделе мы познакомимся с синтаксическим анализом аргументов и модулем, используемым для анализа аргументов

## &#x20;Аргументы командной строки в Python

Мы можем запустить программу с дополнительными аргументами в командной строке. Программы на Python могут запускаться с аргументами командной строки. Давайте рассмотрим пример:

```
$ python program_name.py img.jpg
```

Здесь program\_name.py и img.jpg являются аргументами.

Теперь мы собираемся использовать модули для получения аргументов:

| Модуль   | **Использование**                                                                   | **Python version** |
| -------- | ----------------------------------------------------------------------------------- | ------------------ |
| optparse | Deprecated                                                                          | < 2.7              |
| sys      | Все аргументы в файле sys.argv (basic)                                              | All                |
| argparse | Создание интерфейса командной строки                                                | >= 2.3             |
| fire     | Automatically generating Автоматическое создание интерфейсов командной строки (CLI) | All                |
| docopt   | Создание CLIs-интерфейсов                                                           | >= 2.5             |

## &#x20;Sys.argv

Модуль sys используется для доступа к параметрам командной строки. Функция len(sys.argv) содержит количество аргументов. Чтобы вывести все аргументы, просто выполните команду str(sys.argv). Давайте рассмотрим пример:

```
01.py
import sys
print('Number of arguments:', len(sys.argv))
print('Argument list:', str(sys.argv))

Output:
Python3 01.py img
Number of arguments 2
Arguments list: ['01.py', 'img']
```

## &#x20;Принятие решений

Когда мы хотим выполнить блок кода при выполнении условия true, на помощь приходит процесс принятия решений. Оператор if...elif...else используется в Python для принятия решений.

## &#x20;Синтаксис оператора if в Python

Ниже приведен синтаксис оператора if:

```
if test_expression:
    statement(s)
```

Здесь программа вычисляет тестовое выражение и выполняет инструкции только в том случае, если текстовое выражение истинно. Если текстовое выражение ложно, инструкции не выполняются.

В Python текст инструкции if обозначается отступом. Текст начинается с отступа, а первая строка без отступа указывает на конец. Давайте рассмотрим пример:

```
a = 10
if a > 0:
    print(a, "is a positive number.")
print("This statement is always printed.")

a = -10
if a > 0:
    print(a, "is a positive number.")

Output:
10 is a positive number.
This statement is always printed.
```

## &#x20;Синтаксис оператора   if...else Python

В этом разделе мы познакомимся с оператором if..else. Блок else будет выполнен только в том случае, если условие if равно false. Обратитесь к следующему синтаксису:

```
if test expression:
    if block
else:
    else block
```

Оператор if..else вычисляет тестовое выражение и выполняет основную часть if только в том случае, если условие теста истинно. Если условие ложно, выполняется основная часть else. Для разделения блоков используется отступ. Обратитесь к следующему примеру:

```
a = 10
if a > 0:
    print("Positive number")
else:
    print("Negative number")

Output:
Positive number
```

## &#x20;Оператор Python if...elif...else

Оператор elif проверяет несколько операторов на наличие истинного значения. Всякий раз, когда значение принимает значение true, выполняется этот блок кода. Обратитесь к следующему синтаксису:

```
if test expression:
    if block statements
elif test expression:
    elif block statements
else:
    else block statements
```

**`elif`** - это сокращение от **`else if`**. Это позволяет нам проверять наличие нескольких выражений. Если условие, записанное в операторе if, ложно, то оно проверит условие следующего блока elif и так далее. Если все условия ложны, выполняется основная часть else.

Только один блок из нескольких блоков if...elif...else выполняется в соответствии с условием. Блок if может содержать только один блок else. Но он может содержать несколько блоков elif. Давайте рассмотрим один пример:

```
a = 10
if a > 50:
 print("a is greater than 50")
elif a == 10:
 print("a is equal to 10")
else:
 print("a is negative")

Output:
a is equal to 10
```

## Циклы

Чтобы удовлетворить все требования к циклированию в вашем скрипте, Python поддерживает два цикла:

* for цикл
* while цикл

Теперь мы познакомимся с циклом for и циклом while.

## &#x20;Цикл for

Цикл for выполняет итерацию по каждому элементу последовательности или любому другому повторяемому объекту и каждый раз выполняет инструкции в блоке for. Обратитесь к следующему синтаксису:

```
for i in sequence:
    for loop body
```

Здесь i - это переменная, которая принимает значение элемента внутри последовательности на каждой итерации. Этот цикл продолжается до тех пор, пока мы не достигнем последнего элемента в последовательности. Это показано на следующей диаграмме:

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Обратитесь к следующему примеру:

```
numbers = [6, 5, 3, 8, 4, 2, 5, 4, 11]
sum = 0
for i in numbers:
 sum = sum + i
 print("The sum is", sum)

Output:
The sum is 6
The sum is 11
The sum is 14
The sum is 22
The sum is 26
The sum is 28
The sum is 33
The sum is 37
The sum is 48
```

## &#x20;Функция range()

Функция **`range()`** в Python сгенерирует последовательность чисел. Например, range(10) сгенерирует числа от 0 до 9 (10 чисел).

Мы также можем определить начало, остановку и размер шага в качестве параметров, и range() будет выглядеть следующим образом:

```
range(start, stop, step size).
Step size defaults to 1 if not provided.
For loop example using range() function:
```

Давайте рассмотрим один пример:

```
for i in range(5):
 print("The number is", i)

Output:
The number is 0
The number is 1
The number is 2
The number is 3
The number is 4
```

## &#x20;Цикл while

**`While`** - это оператор цикла, который выполняет итерацию по блоку кода до тех пор, пока введенное тестовое выражение не станет истинным. Мы используем этот цикл, когда не знаем, сколько раз будут выполняться итерации. Обратитесь к следующему синтаксису:

```
while test_expression:
    while body statements
```

В цикле while сначала мы проверяем тестовое выражение. Блок while будет выполнен, только если тестовое выражение истинно. После одной итерации выражение будет проверено снова, и этот процесс будет продолжаться до тех пор, пока значение test\_expression не будет равно false. Это проиллюстрировано на следующей диаграмме:

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Ниже приведен пример цикла while:

```
a = 10
sum = 0
i = 1
while i <= a:
    sum = sum + i
    i = i + 1
    print("The sum is", sum)


Output:
The sum is 1
The sum is 3
The sum is 6
The sum is 10
The sum is 15
The sum is 21
The sum is 28
The sum is 36
The sum is 45
The sum is 55
```

## &#x20;Итераторы

В Python итератор - это объект, по которому можно выполнять итерации. Это объект, который возвращает данные по одному элементу за раз. Объект-итератор в Python реализует два метода: **iter**() и **next**(). В основном итераторы реализуются в циклах, генераторах и обобщениях<mark style="background-color:blue;">(? Обработчиках?(comprehensions)) comprehensions - списковые включения.</mark>

В следующем примере мы используем функцию next(), которая выполняет итерацию по всем элементам. После достижения конца и отсутствия дополнительных данных, подлежащих возврату, будет запущена функция StopIteration:

```
numbers = [10, 20, 30, 40]

numbers_iter = iter(numbers)

print(next(numbers_iter))
print(next(numbers_iter))
print(numbers_iter.__next__())
print(numbers_iter.__next__())

next(numbers_iter)

Output:
10
20
30
40
Traceback (most recent call last):
  File "sample.py", line 10, in <module>
    next(numbers_iter)
StopIteration

```

## &#x20;Генераторы

Мы можем создавать итераторы, используя генераторы Python. В Python генератор - это функция, которая возвращает объект, по которому мы можем выполнять итерации.

## &#x20;Как создать генератор на Python?

Создать генератор в Python несложно. Вы можете создать генератор, просто определив функцию с инструкцией yield вместо инструкции return. Если функция содержит хотя бы одну инструкцию yield, она становится функцией-генератором. Инструкции yield и return будут возвращать некоторое значение из функции. Вот пример:

```
def my_gen():
    n = 1
    print('This is printed first')
    yield n
    n += 1
    print('This is printed second')
    yield n
    n += 1
    print('This is printed at last')
    yield n
    for item in my_gen():
        print(item)

Output:
This is printed first
1
This is printed second
2
This is printed at last
3
```

Генераторы и списковые включения (или генераторы списков, они же comprehensions) — это две разные концепции в Python.

**Генераторы** — это функции, которые возвращают итератор. Они позволяют создавать последовательности значений без необходимости заранее создавать весь список в памяти. Генераторы определяются с помощью ключевого слова yield вместо return. Когда генератор вызывается, он возвращает итератор, который можно использовать для получения значений по одному.

Пример генератора:

```
def square_generator():
    for x in range(10):
        yield x * x
```

В этом примере функция square\_generator() является генератором, который будет возвращать квадраты чисел при каждом вызове.

**Списковые включения** — это более простой и лаконичный способ создания списков на основе итерируемых объектов. Они состоят из выражения-итерации, за которым следует необязательное условие фильтрации, заключённое в квадратные скобки. Результатом является новый список, множество или словарь, который создаётся на основе итерируемого объекта.

Пример:\
`[x * x for x in range(6)]`\
Этот код создаст список квадратов чисел от 0 до 5.

Разница между генераторами и списковыми включениями заключается в том, что первые возвращают итераторы, а вторые сразу создают списки, словари и множества.

## Функции

**Функция** - это набор инструкций, которые выполняют определенную задачу. Использование функций помогает разбить нашу программу на более мелкие части. Программы будут более организованными, если мы будем использовать функции, поскольку это позволяет избежать повторения и повторно использовать код. Посмотрите на следующий синтаксис:

```
def function_name(parameters):
    statement(s)
```

Обратитесь к следующему примеру:

```
def welcome(name):
    print("Hello " + name + ", Welcome to Python Programming !")

welcome("John")

Output:
Hello John, Welcome to Python Programming !
```

## &#x20;Оператор возврата&#x20;

Оператор return используется для выхода из функции. Обратитесь к следующему синтаксису:

```
return [expression_list]
```

Этот оператор может содержать выражение, в котором должно быть возвращено значение. Если выражения нет, то функция вернет объект None, как показано в следующем примере:

```
def return_value(a):
    if a >= 0:
        return a
    else:
        return -a
print(return_value(2))
print(return_value(-4))

Output:
2
4
```

## &#x20;Лямбда-функции

В Python анонимная функция - это функция, которая определяется без имени и называется лямбда-функцией, поскольку она определяется с помощью ключевого слова **lambda**. Мы используем эти функции всякий раз, когда нам требуется функция на короткий промежуток времени.

Лямбда-функции используются наряду со встроенными функциями, такими как **filter()** и **map()**.

Функция **filter()** возвращает список элементов и имеет только один повторяющийся элемент в качестве входных данных. Ниже показан пример использования **filter()**:

```
mbers = [10, 25, 54, 86, 89, 11, 33, 22]
new_numbers = list(filter(lambda x: (x%2 == 0) , numbers))
print(new_numbers)

Output:
[10, 54, 86, 22]
```

В этом примере функция filter() принимает лямбда-функцию и список в качестве аргумента.

Функция map() возвращает список результатов после применения указанной функции. Теперь давайте рассмотрим пример использования map():

```
my_list = [1, 5, 4, 6, 8, 11, 3, 12]
new_list = list(map(lambda x: x * 2 , my_list))
print(new_list)

Output:
[2, 10, 8, 12, 16, 22, 6, 24]
```

Здесь функция map() использует лямбда-функцию и список.

## &#x20;Модули

**Модули** - это просто файлы, содержащие инструкции и определения Python. Файл, содержащий код на Python (например, sample.py), называется модулем, а его имя - sample. Используя модули, мы можем разбивать большие программы на небольшие и упорядоченные. Важной особенностью модуля является возможность повторного использования. Вместо копирования определений наиболее часто используемых функций в разных программах, вы можете определить их в модуле и просто импортировать при необходимости.

Давайте создадим модуль и импортируем его. Мы создадим два скрипта: sample.py и add.py. Мы импортируем smaple модуль в наш add.py. Теперь сохраните следующий код как sample.py. Давайте рассмотрим его на следующем примере:

```
sample.py
def addition(num1, num2):
    result = num1 + num2
    return result
```

Здесь мы определили функцию addition() внутри модуля с именем sample. Функция принимает два числа и возвращает их сумму. Теперь мы создали модуль. Вы можете импортировать это в любую программу на Python.

## &#x20;Импорт модулей

Теперь, после создания модуля, мы научимся импортировать этот модуль. В предыдущем примере мы создали модуль sample. Теперь мы будем импортировать sample модуль в скрипт add.py&#x20;

```
add.py
import sample
sum = sample.addition(10, 20)
print(sum)

Output:
30
```

## &#x20;Резюме

В этой главе мы дали обзор языка сценариев Python. Мы узнали о том, как установить Python и различные инструменты. Мы также узнали об интерпретаторе Python и о том, как им пользоваться. Мы узнали о поддерживаемых Python типах данных, переменных, числах и строках, инструкциях для принятия решений и циклических инструкциях в Python. Мы также узнали о функциях и о том, как их использовать в скриптах и модулях, а также о том, как их создавать и импортировать.

В следующей главе, посвященной отладке и профилированию сценариев на Python, вы узнаете о методах отладки на Python, обработке ошибок (exception handling), инструментах отладчика, отладке основных сбоев программ, профилировании и синхронизации программ, а также ускорении работы программ.

## &#x20;Вопросы

1. Что такое итераторы и генераторы?
2. Списки изменяемы или неизменяемы?
3. Что такое структуры данных в Python?&#x20;
4. Как получить доступ к значениям в списке?&#x20;
5. Что такое модули?

## &#x20;Рекомендованное чтение

Вся документация по Python доступна на следующем сайте: www.python.org.

Вы также можете ознакомиться со следующими книгами: Learn Python Hard Way и Byte of Python, в которых рассказывается об основах Python







