# Программы профилирования и синхронизации

Профилирование программы на Python означает измерение времени выполнения программы. Оно измеряет время, затрачиваемое на выполнение каждой функции. Модуль cProfile Python используется для профилирования программ на Python.

## &#x20;Модуль cProfile&#x20;

Как обсуждалось ранее, профилирование означает измерение времени выполнения программы. Мы собираемся использовать модуль **cProfile** для профилирования программы.

Теперь мы напишем cprof\_example.py скрипт и введем в него следующий код:

```python
mul_value = 0
def mul_numbers( num1, num2 ):
            mul_value = num1 * num2;
            print ("Local Value: ", mul_value)
            return mul_value
mul_numbers( 58, 77 )
print ("Global Value: ", mul_value)
```

Запустите программу, и вы увидите результат следующим образом:

```sh
student@ubuntu:~$ python3 -m cProfile cprof_example.py
Local Value:  4466
Global Value:  0
         6 function calls in 0.000 seconds
   Ordered by: standard name
 
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 cprof_example.py:1(<module>)
        1    0.000    0.000    0.000    0.000 cprof_example.py:2(mul_numbers)
        1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
        2    0.000    0.000    0.000    0.000 {built-in method builtins.print}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```

Таким образом, при использовании profile все вызываемые функции будут напечатаны с указанием времени, затраченного на выполнение каждой функции. Теперь мы увидим, что означают заголовки этих столбцов:

* ncalls: Количество вызовов
* **tottime**: Общее время, затраченное на выполнение данной функции
* percall: Частное от общего времени, деленного на количество
* cumtime: Суммарное время, затраченное на выполнение этой и всех подфункций
* percall: Частное от общего времени, деленного на простые вызовы
* filename:lineno(function): Предоставляет соответствующие данные для каждой функции

## &#x20;Модуль timeit

**timeit** - это модуль Python, используемый для определения времени выполнения небольших частей вашего скрипта на Python. Вы можете вызвать timeit из командной строки, а также импортировать модуль timeit в свой скрипт. Мы собираемся написать скрипт для определения времени выполнения фрагмента кода. Создайте timeit\_example.py скрипт и запишите в него следующее содержимое:

```python
import timeit
prg_setup = "from math import sqrt"
prg_code = '''
def timeit_example():
            list1 = []
            for x in range(50):
                        list1.append(sqrt(x))
'''
# timeit statement
print(timeit.timeit(setup = prg_setup, stmt = prg_code, number = 10000))
```

Используя timeit, мы можем решить, в каком фрагменте кода мы хотим измерить производительность. Таким образом, мы можем легко определить установочный код, а также фрагмент кода, на котором мы хотим выполнить тест отдельно. Основной код выполняется 1 миллион раз, что является временем по умолчанию, в то время как установочный код выполняется только один раз.

## &#x20;Ускорение работы программ

Существуют различные способы ускорить работу ваших программ на Python, например, следующие:

* Профилируйте свой код, чтобы можно было выявить узкие места
* Используйте встроенные функции и библиотеки, чтобы интерпретатору не приходилось выполнять циклы
* Избегайте использования глобальных переменных, поскольку Python очень медленно обращается к глобальным переменным
* Используйте существующие пакеты

## &#x20;Резюме

В этой главе мы узнали о важности отладки и профилирования программ. Мы узнали о различных методах, доступных для отладки. Мы узнали об отладчике pdb Python и о том, как обрабатывать исключения. Мы узнали о том, как использовать модули cProfile и timeit в Python для профилирования и синхронизации наших скриптов. Мы также узнали, как ускорить выполнение ваших скриптов.

В следующей главе мы познакомимся с модульным тестированием на Python. Мы собираемся узнать о создании и использовании модульных тестов.

## &#x20;Вопросы

* Какой модуль используется для отладки программы?&#x20;

Для отладки программ на Python используются различные модули и инструменты. Вот некоторые из них:

1. Модуль pdb — позволяет выполнять пошаговую отладку программы, устанавливать точки останова, просматривать значения переменных и т. д.
2. IDE (интегрированная среда разработки), такие как PyCharm, Visual Studio Code и другие, предоставляют инструменты для отладки кода.
3. Сторонние инструменты для отладки, такие как WinPDB, которые позволяют удобно выполнять отладку в командной строке.
4. Встроенный модуль traceback — помогает анализировать трассировку стека при возникновении исключений.
5. Логирование с использованием модуля logging — позволяет записывать информацию о выполнении программы для последующего анализа.
6. Сторонний модуль pytest — предоставляет возможности для написания тестов и отладки кода с помощью утверждений (assert).

* Проверьте, как использовать ipython, а также все псевдонимы и магические функции.

**IPython** — это интерактивная оболочка для языка Python, которая предоставляет расширенные возможности для работы с кодом. Вот несколько основных функций и команд IPython:

1. **Интерактивный режим**: IPython позволяет выполнять код в интерактивном режиме, что удобно для тестирования и отладки. Вы можете вводить команды и сразу же видеть результат их выполнения.
2. **Автодополнение кода**: В IPython есть функция автодополнения кода, которая помогает быстро находить и использовать функции, классы и методы. Просто начните вводить имя объекта, и IPython предложит возможные варианты завершения.
3. **Магические функции**: Магические функции в IPython позволяют выполнять различные операции без явного вызова функций или методов. Например, `%timeit` позволяет измерить время выполнения кода, а `%matplotlib inline` включает отображение графиков в блокноте Jupyter.
4. **Псевдонимы**: Псевдонимы(aliases) в IPython используются для сокращения длинных команд. Например, вы можете использовать `%paste` вместо `get_ipython().magic('paste')` для вставки кода из буфера обмена.
5. **История команд**: В IPython можно просматривать историю команд и повторно выполнять их с помощью стрелок вверх и вниз. Также можно использовать функцию `%history` для просмотра истории команд.
6. **Настройка среды**: IPython предоставляет возможность настраивать среду выполнения с помощью конфигурационных файлов. Это позволяет изменять параметры отображения, настройки автозаполнения и другие аспекты работы оболочки.

Чтобы начать работу с IPython, выполните следующие шаги:

* Установите Python и пакетный менеджер pip.
* Используйте команду `pip install ipython` для установки IPython.
* Запустите IPython с помощью команды `ipython`.

После запуска IPython вы увидите приглашение `(In [1]:)`, где можно вводить команды. Для получения справки по командам и функциям используйте функцию `help()` или `?`.

Вот некоторые полезные магические функции и псевдонимы:

| Функция       | Описание                                               |
| ------------- | ------------------------------------------------------ |
| `%run`        | Выполняет файл Python.                                 |
| `%debug`      | Входит в режим отладки после возникновения исключения. |
| `%pdb`        | Запускает отладчик PDB.                                |
| `%autoreload` | Автоматически перезагружает модули при изменении.      |
| `%who`        | Показывает список определённых переменных.             |
| `%whos`       | Показывает                                             |

* Что такое глобальная блокировка интерпретатора **Global interpreted lock** (GIL)?&#x20;

**Global Interpreter Lock (GIL)** — это механизм, который используется во многих интерпретаторах для управления доступом к ресурсам интерпретатора. В контексте Python GIL является мьютексом((от англ. mutex, mutual exclusion — «взаимное исключение») — это механизм синхронизации, который используется для защиты критических секций кода или ресурсов от одновременного доступа нескольких потоков или процессов. Мьютекс позволяет только одному потоку или процессу получить доступ к ресурсу в данный момент времени, блокируя остальные потоки или процессы до тех пор, пока первый поток или процесс не освободит ресурс.) Это означает, что даже если программа на Python использует многопоточность, одновременно может выполняться только один поток.

Основная цель GIL — обеспечить безопасность глобальных данных интерпретатора, таких как словари и внутренние структуры данных C. Без GIL потоки могли бы изменять эти данные одновременно, что могло бы привести к непредсказуемому поведению программы.

Однако GIL также имеет некоторые недостатки:

1. Он ограничивает параллельное выполнение кода на уровне C, что может снизить производительность при выполнении некоторых операций.
2. Из-за GIL Python не может эффективно использовать все ядра процессора в многопроцессорных системах.

Несмотря на эти ограничения, GIL остаётся важной частью Python и обеспечивает стабильность и безопасность выполнения программ на этом языке.

* Каково назначение переменных окружения PYTHONSTARTUP, PYTHONCASEOK, PYTHONHOME и PYTHONSTARTUP?

**PYTHONSTARTUP** — это переменная среды, которая позволяет задать путь к файлу с кодом, который будет автоматически выполняться каждый раз при запуске интерпретатора Python. Этот файл может содержать настройки конфигурации, импорт дополнительных модулей и другие команды, которые вы хотите выполнять при каждом запуске Python.

**PYTHONCASEOK** — эта переменная определяет, будет ли Python учитывать регистр символов при поиске файлов модулей. Если PYTHONCASEOK установлена в значение «1» или «true», то поиск файлов модулей будет учитывать регистр, а если она равна «0» или не задана, то регистр игнорируется.

**PYTHONHOME** — указывает на каталог, содержащий установку Python на компьютере. Эта переменная используется для поиска модулей, когда путь к ним не указан явно.

**PYTHONSTARTUP**, **PYTHONCASEOK** и **PYTHONHOME** являются специфическими для операционной системы Windows переменными среды. В других операционных системах могут быть аналогичные механизмы для настройки запуска Python и поиска модулей.

* &#x20;Каков результат выполнения следующего кода?

&#x20;a) \[0],&#x20;

b) \[1],&#x20;

c) \[1, 0],

&#x20;d) \[0, 1].

```python
def foo(k):
    k = [1]
q = [0]
foo(q)
print(q)
```

Результат выполнения этого кода будет равен `[0]`.

В функции `foo` происходит создание нового списка `[1]` и присвоение его локальной переменной `k`. Однако это изменение не влияет на значение переданного аргумента `q`, который остаётся равным `[0]`, поскольку в Python аргументы передаются по значению.

* Какая из перечисленных ниже переменных недопустима?

a) my\_string\_1&#x20;

b) 1st\_string&#x20;

c) foo&#x20;

d) \_

Недопустимой переменной из перечисленных является **с) foo**, так как это ключевое слово в Python, которое используется для определения функций. Использовать его в качестве имени переменной не рекомендуется.

## Рекомендуется к прочтению

* Как справиться с проблемами GIL в python: [https://realpython.com/python-gil/](https://realpython.com/python-gil/)
* Проверьте, как использовать pdb-модуль в командной строке: [https://fedoramagazine.org/getting-started-python-debugger/](https://fedoramagazine.org/getting-started-python-debugger/)
